// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/maybe ./support/utils ../support/utils ../support/adapters/support/layerUtils".split(" "),function(m,b,v,n,p,q){function w(a){return f.apply(this,arguments)}function f(){f=m._asyncToGenerator(function*(a){if(!a||!a.layer||!a.field&&!a.valueExpression)throw new b("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(a.valueExpression&&!a.view)throw new b("class-breaks:missing-parameters",
"View is required when 'valueExpression' is specified");var c=[0,2,1,3,5];const {layer:g,...x}=a;var d=q.createLayerAdapter(g,c);a={layerAdapter:d,...x};a.normalizationType=p.getNormalizationType(a);a.numClasses=a.numClasses||5;if(!d)throw new b("class-breaks:invalid-parameters","'layer' must be one of these types: "+q.getLayerTypeLabels(c).join(", "));c=v.isSome(a.signal)?{signal:a.signal}:null;yield d.load(c);var e=a.field;c=a.minValue;const h=a.maxValue,y=null!=c||null!=h,r=a.classificationMethod,
t="percent-of-total"===a.normalizationType,u=!1!==a.analyzeData;e=e?d.getField(e):null;var k=yield p.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression});if(k=n.verifyBasicFieldValidity(d,k,"class-breaks:invalid-parameters"))throw k;if(e&&(d=n.verifyNumericField(d,e,"class-breaks:invalid-parameters")))throw d;if(a.valueExpression&&a.normalizationType)throw new b("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");
if(y)if(u){if(t&&null==a.normalizationTotal)throw new b("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified");}else{if(null==c||null==h)throw new b("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(c>=h)throw new b("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(r&&"equal-interval"!==r)throw new b("class-breaks:invalid-parameters",
"'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(t&&null==a.normalizationTotal)throw new b("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false");}else if(!u)throw new b("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");return a});return f.apply(this,arguments)}function l(){l=m._asyncToGenerator(function*(a){const {layerAdapter:c,
...g}=yield w(a);return c.classBreaks(g)});return l.apply(this,arguments)}return function(a){return l.apply(this,arguments)}});