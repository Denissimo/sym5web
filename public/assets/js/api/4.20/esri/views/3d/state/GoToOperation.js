// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("exports ../../../Camera ../../../Viewpoint ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/watchUtils ../camera/constraintUtils ./controllers/CameraController ./controllers/PointToPointAnimationController ./controllers/SurfaceCollisionCorrectionController ../support/cameraUtils ../support/viewpointUtils ../camera/constraintUtils/surfaceCollision".split(" "),function(p,r,t,l,d,m,u,v,h,n,w,x,y,z){let A=function(){function q(a,b,c){this.target=a;this.options=
b;this.view=c;this.state="pending";this.animationController=this.abortController=null;this.promise=new Promise((g,k)=>{this.resolveCallback=g;this.rejectCallback=k;g=m.createAbortController();if(d.isSome(this.options.signal))m.onAbort(this.options.signal,()=>{this.abort()});this.abortController=g;this.waitForReady()})}var f=q.prototype;f.then=function(a,b){return this.promise.then(a,b)};f.catch=function(a){return this.promise.catch(a)};f.resolve=function(a){this.state="finished";return this.resolveCallback(a)};
f.reject=function(a){this.state="finished";return this.rejectCallback(a)};f.abort=function(a=!1){switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":this.reject(m.createAbortError());break;case "wait-for-animation-finish":!a&&d.isSome(this.animationController)&&this.view.state.cameraController===this.animationController&&this.animationController.active&&this.animationController.stopController(),this.reject(m.createAbortError())}};f.waitForReady=function(){this.state=
"wait-for-ready";this.view.ready?this.createViewPoint():u.whenOnce(this.view,"ready",this.abortController.signal).then(()=>{this.createViewPoint()},a=>{this.reject(a)})};f.createViewPoint=function(){"finished"!==this.state&&(this.state="wait-for-viewpoint",this.animationController=this.options.animate?this.getAnimationController():null,y.create(this.view,this.target,this.abortController.signal).then(a=>{"finished"!==this.state&&(a=this.getCameraFromViewpoint(a),d.isNone(a)||(this.options.animate?
d.isNone(this.animationController)||this.startAnimation(a,this.animationController):(this.view.stateManager.setStateCamera(a.camera,{applyConstraints:!a.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve())))},a=>{this.reject(a)}))};f.getCameraFromViewpoint=function(a){const b=!!(this.target instanceof t&&this.target.camera||this.target instanceof r);var c=a.camera;if(d.isNone(c))return null;if(!this.view.stateManager.isCompatible(c))return a=(a=c.position)&&
a.spatialReference,this.reject(new l("GotoAnimation:incompatible-spatialreference",`Resulting camera has an incompatible spatial reference (camera: ${a?a.wkid:"none"}, view: ${this.view.spatialReference.wkid})`,{camera:c})),null;c=x.externalToInternal(this.view,c);return d.isNone(c)?(this.reject(new l("GotoAnimation:invalid-camera","Resulting camera is invalid")),null):{viewpoint:a,camera:c,isFullySpecified:b}};f.startAnimation=function(a,b){this.state="wait-for-animation-finish";const c=b.viewAnimation;
if(d.isNone(c))this.reject(new l("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));else{c.update(a.viewpoint,"running");if(!b.active||d.isNone(b.viewAnimation)||b.viewAnimation.target!==a.viewpoint||this.view.state.cameraController!==b)return this.abort();if(a.isFullySpecified){var g=new w.SurfaceCollisionCorrectionController({view:this.view,desiredCamera:a.camera});z.applySurfaceCollisionConstraint(this.view,a.camera,1)}else v.applyAll(this.view,a.camera);b.begin(a.camera,
this.options);var k=e=>{if(!d.isNone(this.view.state))switch(b.state){case h.State.Finished:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.resolve()}break;case h.State.Ready:case h.State.Rejected:case h.State.Running:case h.State.Stopped:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.reject(e)}}};c.when(()=>{const e=this.view.state.cameraController;g&&(e&&
e.active?e instanceof n.PointToPointAnimationController&&d.isSome(e.viewAnimation)&&e.viewAnimation.target===a.viewpoint&&(this.view.state.cameraController=g):d.isSome(b.viewAnimation)&&b.viewAnimation.target===a.viewpoint&&"finished"===b.state&&(this.view.state.cameraController=g))},e=>k(e));b.asyncResult={resolve:()=>k(),reject:e=>k(e)}}};f.getAnimationController=function(){let a;var b=null;b=this.view.state.cameraController;b instanceof n.PointToPointAnimationController&&(b.updateStateFromViewAnimation(),
b.active&&(a=b,b=a.viewAnimation));return null!=a||(a=new n.PointToPointAnimationController({view:this.view,mode:"animation"}),b=a.viewAnimation,this.view.state.switchCameraController(a))?a:(d.isSome(b)&&b.stop(),this.reject(new l("GotoAnimation:goto-cannot-interrupt","Cannot start an animation while interacting")),null)};return q}();p.GoToOperation=A;Object.defineProperty(p,"__esModule",{value:!0})});