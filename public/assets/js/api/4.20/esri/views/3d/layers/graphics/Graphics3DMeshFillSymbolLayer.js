// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../Color ../../../../core/has ../../../../core/maybe ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../chunks/vec4f64 ../../../../geometry/projection ../../../../geometry/support/aaBoundingBox ../../../../geometry/support/MeshComponent ../../../../geometry/support/MeshMaterialMetallicRoughness ../../../../geometry/support/buffer/BufferView ../../../../chunks/vec32 ../../../../geometry/support/meshUtils/projection ../../../../layers/graphics/dehydratedFeatures ./ElevationAligners ./elevationAlignmentUtils ./ElevationContext ./Graphics3DObject3DGraphicLayer ./Graphics3DSymbolLayer ../support/edgeUtils ../support/symbolColorUtils ../../support/debugFlags ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/geometryDataUtils ../../webgl-engine/lib/Object3D ../../webgl-engine/lib/Texture ../../webgl-engine/materials/DefaultMaterial ../../webgl-engine/materials/NativeLineMaterial".split(" "),
function(K,T,H,L,h,U,ba,M,z,w,A,V,B,I,ca,da,N,O,F,ea,fa,W,ha,ia,ja,ka,X,Y,P,la,ma,na,oa,Z){const pa=["mesh"];L=function(Q){function R(a,b,c,d){a=Q.call(this,a,b,c,d)||this;a._materials=new Map;a._textures=new Map;a.ensureDrapedStatus(!1);return a}T._inheritsLoose(R,Q);var g=R.prototype;g.doLoad=function(){var a=T._asyncToGenerator(function*(){Y.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new Z.NativeLineMaterial({color:[1,0,1,1]}),this._debugFaceNormalMaterial=new Z.NativeLineMaterial({color:[0,
1,1,1]}))});return function(){return a.apply(this,arguments)}}();g.destroy=function(){Q.prototype.destroy.call(this);this._context.stage.removeMany(Array.from(this._materials.values(),a=>a.material));this._context.stage.removeMany(Array.from(this._textures.values()));this._materials.clear();this._textures.clear()};g.createGraphics3DGraphic=function(a){const b=a.graphic;if(!this._validateGeometry(b.geometry,pa,"fill on mesh-3d"))return null;const c=this.setGraphicElevationContext(b,new ha.ElevationContext);
return this._createAs3DShape(b,a.renderingInfo,c,b.uid)};g.layerOpacityChanged=function(a,b){const c=this._getLayerOpacity();this._materials.forEach(d=>{d.material.setParameterValues({layerOpacity:c});const e=d.material.params;this._setMaterialTransparentParameter(e,d);d.material.setParameterValues({transparent:e.transparent})});a.forEach(d=>{d=b(d);h.isSome(d)&&d.layerOpacityChanged(c,this._context.isAsync)});return!0};g.layerElevationInfoChanged=function(a,b){return this.updateGraphics3DGraphicElevationInfo(a,
b,W.needsElevationUpdates3D)};g.slicePlaneEnabledChanged=function(a,b){this._materials.forEach(c=>{c.material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled})});a.forEach(c=>{c=b(c);h.isSome(c)&&c.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)});return!0};g.physicalBasedRenderingChanged=function(){const a=this._usePBR();this._materials.forEach(b=>b.material.setParameterValues({usePBR:a}));return!0};g.pixelRatioChanged=function(){return!0};g._requiresSymbolVertexColors=
function(){return this._drivenProperties.color||this._drivenProperties.opacity};g._colorOrTextureUid=function(a){return h.isNone(a)?"-":a instanceof H?a.toHex():a.contentHash};g._materialPropertiesDefault=function(a,b){const c=this._requiresSymbolVertexColors(),d=!!a.vertexAttributes.color;a=!!a.vertexAttributes.tangent;return{hasSymbolVertexColors:c,hasVertexColors:d,hasVertexTangents:a,uid:`vc:${d},vt:${a},vct${b},svc:${c}`}};g._materialProperties=function(a,b,c){a=this._materialPropertiesDefault(a,
c);if(!b.material)return a;const {color:d,colorTexture:e,normalTexture:f,doubleSided:k,alphaCutoff:l,alphaMode:x}=b.material;c=this._colorOrTextureUid(d);var u=this._colorOrTextureUid(e),m=this._colorOrTextureUid(f);a.color=d;a.colorTexture=e;a.normalTexture=f;a.uid=`${a.uid},cmuid:${c},ctmuid:${u},ntmuid:${m},ds:${k},ac:${l},am:${x}`;if(b.material instanceof da){const {metallic:y,roughness:p,metallicRoughnessTexture:t,emissiveColor:q,emissiveTexture:v,occlusionTexture:r}=b.material;b=this._colorOrTextureUid(t);
c=this._colorOrTextureUid(q);u=this._colorOrTextureUid(v);m=this._colorOrTextureUid(r);a.metallic=y;a.roughness=p;a.metallicRoughnessTexture=t;a.emissiveColor=q;a.emissiveTexture=v;a.occlusionTexture=r;a.uid=`${a.uid},mrm:${y},mrr:${p},mrt:${b},emuid:${c},etmuid:${u},otmuid:${m}`}return a};g._setInternalColorValueParameters=function(a,b){b.diffuse=H.toUnitRGB(a);b.opacity=a.a};g._getLoadableTextureResource=function(a){return a.data?a.data:a.url};g._getInternalTextureId=function(a){const b=this._getLoadableTextureResource(a);
if(b){var c=a.contentHash,d=this._textures.get(c);d||(d=new na.Texture(b,{mipmap:!0,wrap:this._castTextureWrap(a.wrap),noUnpackFlip:!0,preMultiplyAlpha:!0}),this._textures.set(c,d),this._context.stage.add(d));return d.id}};g._castTextureWrap=function(a="repeat"){return"string"===typeof a?(a=this._castTextureWrapIndividual(a),{s:a,t:a}):{s:this._castTextureWrapIndividual(a.horizontal),t:this._castTextureWrapIndividual(a.vertical)}};g._castTextureWrapIndividual=function(a){switch(a){case "clamp":return 33071;
case "mirror":return 33648;default:return 10497}};g._setInternalMaterialParameters=function(a,b){h.isSome(a.color)&&this._setInternalColorValueParameters(a.color,b);h.isSome(a.colorTexture)&&(b.textureId=this._getInternalTextureId(a.colorTexture));h.isSome(a.normalTexture)&&(b.normalTextureId=this._getInternalTextureId(a.normalTexture));h.isSome(a.emissiveColor)&&(b.emissiveFactor=H.toUnitRGB(a.emissiveColor));h.isSome(a.emissiveTexture)&&(b.emissiveTextureId=this._getInternalTextureId(a.emissiveTexture));
h.isSome(a.occlusionTexture)&&(b.occlusionTextureId=this._getInternalTextureId(a.occlusionTexture));h.isSome(a.metallicRoughnessTexture)&&(b.metallicRoughnessTextureId=this._getInternalTextureId(a.metallicRoughnessTexture))};g._setExternalMaterialParameters=function(a){var b=this._drivenProperties.color;let c=h.isSome(this.symbolLayer.material)?this.symbolLayer.material.colorMixMode:null;b?a.externalColor=V.ONES:(b=h.isSome(this.symbolLayer.material)?this.symbolLayer.material.color:null,h.isSome(b)?
a.externalColor=H.toUnitRGBA(b):(c=null,a.externalColor=V.ONES));c&&(a.colorMixMode=c);a.castShadows=!!this.symbolLayer.castShadows};g._hasTransparentVertexColors=function(a){a=a.vertexAttributes.color;if(h.isNone(a))return!1;for(let b=3;b<a.length;b+=4)if(255!==a[b])return!0;return!1};g._getOrCreateMaterial=function(a,b){var c=b.material&&b.material.color,d=b.material&&b.material.colorTexture,e=b.material&&"blend"===b.material.alphaMode;c=!(b.material&&"opaque"===b.material.alphaMode)&&(this._hasTransparentVertexColors(a)||
h.isSome(c)&&1>c.a||h.isSome(d)&&d.transparent||e);a=this._materialProperties(a,b,c);if(d=this._materials.get(a.uid))return d.material;c={material:null,isComponentTransparent:c,alphaMode:b.material?b.material.alphaMode:"opaque"};d=null==a.metallicRoughnessTexture&&null==a.metallic&&null==a.roughness;e={usePBR:this._usePBR(),isSchematic:d,vertexColors:a.hasVertexColors,symbolColors:a.hasSymbolVertexColors,vertexTangents:a.hasVertexTangents,ambient:A.ZEROS,diffuse:A.ONES,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",
cullFace:0,textureAlphaPremultiplied:!0,layerOpacity:this._getLayerOpacity(),slicePlaneEnabled:this._context.slicePlaneEnabled,initTextureTransparent:!0};d||(e.mrrFactors=[null!=a.metallic?a.metallic:1,null!=a.roughness?a.roughness:1,.5]);b.material&&(e.doubleSided=b.material.doubleSided,e.cullFace=b.material.doubleSided?0:2,e.textureAlphaCutoff=b.material.alphaCutoff);this._setInternalMaterialParameters(a,e);this._setExternalMaterialParameters(e);this._setMaterialTransparentParameter(e,c);b=new oa.DefaultMaterial(e);
c.material=b;this._materials.set(a.uid,c);this._context.stage.add(b);return b};g._usePBR=function(){return this._context.physicalBasedRenderingEnabled};g._setMaterialTransparentParameter=function(a,b){a.transparent=this.needsDrivenTransparentPass||b.isComponentTransparent||1>a.layerOpacity||1>a.opacity||a.externalColor&&1>a.externalColor[3];a.textureAlphaMode="auto"===b.alphaMode?a.transparent?3:1:"opaque"===b.alphaMode?1:"mask"===b.alphaMode?2:0};g._addDebugNormals=function(a,b,c,d){var e=b.length,
f=a.spatialReference.isGeographic?20015077/180:1;const k=.1*Math.max(a.extent.width*f,a.extent.height*f,a.extent.zmax-a.extent.zmin),l=[],x=[];a=[];f=[];for(let q=0;q<e;q++){var u=b[q],m=u.vertexAttributes.get("position"),y=u.vertexAttributes.get("normal");const v=u.indices.get("position");u=u.indices.get("normal");m=m.data;y=y.data;for(let r=0;r<v.length;r++){var p=3*v[r];const qa=3*u[r];for(var t=0;3>t;t++)l.push(m[p+t]);for(t=0;3>t;t++)l.push(m[p+t]+y[qa+t]*k);x.push(x.length);x.push(x.length);
if(0===r%3){this._calculateFaceNormal(m,v,r,C);this._getFaceVertices(m,v,r,n,D,E);w.add(n,n,D);w.add(n,n,E);w.scale(n,n,1/3);for(p=0;3>p;p++)a.push(n[p]);for(p=0;3>p;p++)a.push(n[p]+C[p]*k);f.push(f.length);f.push(f.length)}}}e=new P.Geometry([["position",{data:l,size:3,exclusive:!0}]],[["position",new Uint32Array(x)]],2);b.push(e);c.push(this._debugVertexNormalMaterial);d.push(z.clone(d[0]));e=new P.Geometry([["position",{data:a,size:3,exclusive:!0}]],[["position",new Uint32Array(f)]],2);b.push(e);
c.push(this._debugFaceNormalMaterial);d.push(z.clone(d[0]))};g._createAs3DShape=function(a,b,c,d){a=a.geometry;if("mesh"!==a.type)return null;b=this._createGeometryInfo(a,b);if(!b)return null;const {geometries:e,materials:f,transformations:k,objectTransformation:l}=b;Y.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(a,e,f,k);d=new ma.Object3D({geometries:e,materials:f,transformations:k,metadata:{layerUid:this._context.layer.uid,graphicUid:d}});d.transformation=l;b=fa.perObjectElevationAligner;a=
this._createEdgeMaterial();a=h.isSome(a)?{baseMaterial:f[0],edgeMaterials:[a],properties:{mergeGeometries:!0,slicePlaneEnabled:this._context.slicePlaneEnabled}}:null;a=new ia.Graphics3DObject3DGraphicLayer(this,d,e,null,null,b,c,a);a.needsElevationUpdates=W.needsElevationUpdates3D(c.mode);a.useObjectOriginAsAttachmentOrigin=!0;a.elevationContext.centerPointInElevationSR=this.getCenterPointInElevationSR(d);a.alignedSampledElevation=b(a,a.elevationContext,this._context.elevationProvider,this._context.renderCoordsHelper);
return a};g.getCenterPointInElevationSR=function(a){const b=ea.makeDehydratedPoint(0,0,0,this._context.elevationProvider.spatialReference);B.projectVectorToDehydratedPoint([a.transformation[12],a.transformation[13],a.transformation[14]],this._context.renderCoordsHelper.spatialReference,b);return b};g._createComponentNormals=function(a,b,c,d){switch(c.shading||"flat"){case "source":return this._createComponentNormalsSource(a,b,c,d);case "flat":return this._createComponentNormalsFlat(a,d);case "smooth":return this._createComponentNormalsSmooth(a,
d)}};g._createComponentNormalsSource=function(a,b,c,d){if(h.isNone(b))return this._createComponentNormalsFlat(a,d);let e=!1;if(!c.trustSourceNormals)for(c=0;c<d.length;c+=3){this._calculateFaceNormal(a,d,c,C);for(let f=0;3>f;f++){const k=3*d[c+f];n[0]=b[k+0];n[1]=b[k+1];n[2]=b[k+2];0>w.dot(C,n)&&(b[k+0]=-b[k+0],b[k+1]=-b[k+1],b[k+2]=-b[k+2],e=!0)}}return{normals:b,indices:d,didFlipNormals:e}};g._createComponentNormalsFlat=function(a,b){const c=new Float32Array(b.length),d=new Uint32Array(3*b.length);
for(let e=0;e<b.length;e+=3){const f=this._calculateFaceNormal(a,b,e,C);for(let k=0;3>k;k++)c[e+k]=f[k],d[e+k]=e/3}return{normals:c,indices:d,didFlipNormals:!1}};g._createComponentNormalsSmooth=function(a,b){const c={};for(var d=0;d<b.length;d+=3){var e=this._calculateFaceNormal(a,b,d,C);for(var f=0;3>f;f++){var k=b[d+f];let l=c[k];l||(l={normal:A.create(),count:0},c[k]=l);w.add(l.normal,l.normal,e);l.count++}}a=new Float32Array(3*b.length);d=new Uint32Array(3*b.length);for(e=0;e<b.length;e++){f=
c[b[e]];1!==f.count&&(w.normalize(f.normal,f.normal),f.count=1);for(k=0;3>k;k++)a[3*e+k]=f.normal[k];d[e]=e}return{normals:a,indices:d,didFlipNormals:!1}};g._getFaceVertices=function(a,b,c,d,e,f){const k=3*b[c+0],l=3*b[c+1];b=3*b[c+2];d[0]=a[k+0];d[1]=a[k+1];d[2]=a[k+2];e[0]=a[l+0];e[1]=a[l+1];e[2]=a[l+2];f[0]=a[b+0];f[1]=a[b+1];f[2]=a[b+2]};g._calculateFaceNormal=function(a,b,c,d){this._getFaceVertices(a,b,c,n,D,E);w.subtract(D,D,n);w.subtract(E,E,n);w.cross(n,D,E);w.normalize(d,n);return d};g._getOrCreateComponents=
function(a){return a.components?a.components:ra};g._createPositionBuffer=function(a,b){let c=a.vertexAttributes.position;const d=1===b.reprojection?b.transformBeforeProject:null;h.isSome(d)&&(c=F.transformPosition(c,new Float64Array(c.length),d));if(0===b.reprojection)return b.needsBufferCopy?new Float64Array(c):c;b=h.isSome(d)?c:new Float64Array(c.length);B.projectBuffer(c,a.spatialReference,0,b,this._context.renderCoordsHelper.spatialReference,0,c.length/3);return b};g._createNormalBuffer=function(a,
b,c){let d=a.vertexAttributes.normal;if(h.isNone(d))return null;var e=1===c.reprojection?c.transformBeforeProject:null;h.isSome(e)&&(d=F.transformNormal(d,new Float32Array(d.length),e));if("local"===this._context.layerView.view.viewingMode||0===c.reprojection)return c.needsBufferCopy&&a.vertexAttributes.normal===d?new Float32Array(d):d;c=a.vertexAttributes.position;e=h.isSome(e)?d:new Float32Array(d.length);return F.projectNormalToPCPF(d,c,b,a.spatialReference,e)};g._createTangentBuffer=function(a,
b,c){let d=a.vertexAttributes.tangent;if(h.isNone(d))return null;var e=1===c.reprojection?c.transformBeforeProject:null;h.isSome(e)&&(d=F.transformTangent(d,new Float32Array(d.length),e));if("local"===this._context.layerView.view.viewingMode||0===c.reprojection)return c.needsBufferCopy&&a.vertexAttributes.normal===d?new Float32Array(d):d;c=a.vertexAttributes.position;e=h.isSome(e)?d:new Float32Array(d.length);return F.projectTangentToPCPF(d,c,b,a.spatialReference,e)};g._createColorBuffer=function(a){return a.vertexAttributes.color};
g._createSymbolColorBuffer=function(a){if(this._requiresSymbolVertexColors()){a=this._getVertexOpacityAndColor(a);const b=X.parseColorMixMode(h.get(this.symbolLayer,"material","colorMixMode")),c=new Uint8Array(4);X.encodeSymbolColor(a,b,c);return c}return null};g._createBuffers=function(a,b){var c=a.vertexAttributes&&a.vertexAttributes.position;if(!c)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;var d=a.vertexAttributes.normal;const e=a.vertexAttributes.uv;
var f=a.vertexAttributes.tangent;if(h.isSome(d)&&d.length!==c.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(h.isSome(f)&&f.length/4!==c.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(h.isSome(e)&&e.length/2!==c.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),
null;f=this._computeReprojectionInfo(a);c=this._createPositionBuffer(a,f);d=this._createColorBuffer(a);b=this._createSymbolColorBuffer(b);const k=this._createNormalBuffer(a,c,f),l=this._createTangentBuffer(a,c,f);a=0===f.reprojection&&h.isSome(f.objectTransformation)?f.objectTransformation:this._transformOriginLocal(a,c,k,l);f=0===f.reprojection&&h.isSome(f.geometryTransformation)?f.geometryTransformation:z.create();return{positionBuffer:c,normalBuffer:k,tangentBuffer:l,uvBuffer:e,colorBuffer:d,symbolColorBuffer:b,
objectTransformation:a,geometryTransformation:f}};g._computeReprojectionInfo=function(a){const b=h.isSome(a.transform)&&a.transform.geographic?0:2===this._context.renderCoordsHelper.viewingMode?0:1;var c=null;if(h.isSome(a.transform)){if(0===b)return c=z.create(),B.computeLinearTransformation(a.spatialReference,a.transform.origin,c,this._context.renderCoordsHelper.spatialReference),a=z.clone(a.transform.localMatrix),{reprojection:b,objectTransformation:c,geometryTransformation:a,needsBufferCopy:!1};
c=M.fromTranslation(z.create(),a.transform.origin);M.multiply(c,c,a.transform.localMatrix);return{reprojection:b,transformBeforeProject:c,needsBufferCopy:!0}}return{reprojection:b,needsBufferCopy:!0}};g._transformOriginLocal=function(a,b,c,d){const e=this._context.renderCoordsHelper.spatialReference;var f=a.anchor;J[0]=f.x;J[1]=f.y;J[2]=f.z;f=z.create();B.computeLinearTransformation(a.spatialReference,J,f,e);a=N.BufferViewVec3f64.fromTypedArray(b);M.invert(aa,f);O.transformMat4(a,a,aa);if(h.isSome(c)||
h.isSome(d))U.fromMat4(G,f),U.transpose(G,G),h.isSome(c)&&(c=N.BufferViewVec3f.fromTypedArray(c),O.transformMat3(c,c,G)),h.isSome(d)&&(d=N.BufferViewVec3f.fromTypedArray(d,4*d.BYTES_PER_ELEMENT),O.transformMat3(d,d,G));return f};g._validateFaces=function(a,b){a=a.vertexAttributes.position.length/3;if(b=b.faces){let c=-1;for(let d=0;d<b.length;d++){const e=b[d];e>c&&(c=e)}if(a<=c)return this.logger.warn(`Vertex index ${c} is out of bounds of the mesh position buffer`),!1}else if(0!==a%3)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),
!1;return!0};g._getOrCreateFaces=function(a,b){return b.faces?b.faces:la.generateDefaultIndexArray(a.vertexAttributes.position.length/3)};g._isOutsideClippingArea=function(a){if(!this._context.clippingExtent)return!1;var b=a.vertexAttributes&&a.vertexAttributes.position;if(!b)return!1;const c=this._context.elevationProvider.spatialReference,d=b.length/3;a.spatialReference.equals(c)||(b=new Float64Array(b.length),B.projectBuffer(a.vertexAttributes.position,a.spatialReference,0,b,c,0,d));I.empty(S);
I.expandWithBuffer(S,b,0,d);return!I.intersectsClippingArea(S,this._context.clippingExtent)};g._createGeometryInfo=function(a,b){if(!B.canProjectWithoutEngine(a.spatialReference,this._context.layerView.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(a))return null;b=this._createBuffers(a,b);if(h.isNone(b))return null;const {positionBuffer:c,uvBuffer:d,colorBuffer:e,symbolColorBuffer:f,normalBuffer:k,tangentBuffer:l,
objectTransformation:x,geometryTransformation:u}=b;var m=this._getOrCreateComponents(a);b=[];const y=[],p=[];let t=!1;for(const v of m){if(!this._validateFaces(a,v))return null;m=this._getOrCreateFaces(a,v);if(0===m.length)continue;var q=this._createComponentNormals(c,k,v,m);q.didFlipNormals&&(t=!0);const r=[["position",{size:3,data:c,exclusive:!0}],["normal",{size:3,data:q.normals,exclusive:!0}]];q=[["position",m],["normal",q.indices]];h.isSome(e)&&(r.push(["color",{size:4,data:e,exclusive:!0}]),
q.push(["color",m]));h.isSome(f)&&(r.push(["symbolColor",{size:4,data:f,exclusive:!0}]),q.push(["symbolColor",new Uint16Array(m.length)]));h.isSome(d)&&(r.push(["uv0",{size:2,data:d,exclusive:!0}]),q.push(["uv0",m]));h.isSome(l)&&(r.push(["tangent",{size:4,data:l,exclusive:!0}]),q.push(["tangent",m]));m=new P.Geometry(r,q);b.push(m);y.push(u);p.push(this._getOrCreateMaterial(a,v))}t&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals.");
return{geometries:b,transformations:y,materials:p,objectTransformation:x}};g._createEdgeMaterial=function(){const a={opacity:this._getLayerOpacity()};return ka.createMaterial(this.symbolLayer,a)};return R}(ja.Graphics3DSymbolLayer);const J=A.create(),n=A.create(),D=A.create(),E=A.create(),C=A.create(),aa=z.create(),G=ba.create(),S=I.create(),ra=[new ca];K.Graphics3DMeshFillSymbolLayer=L;K.default=L;Object.defineProperty(K,"__esModule",{value:!0})});