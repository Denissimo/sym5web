// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/compilerUtils ../../../../core/urlUtils ../../../../core/Version ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/quat ../../../../chunks/quatf64 ../../../../geometry/support/buffer/BufferView ../../../../chunks/scalar ./BinaryStreamReader ./fillDefaults ./pathUtils".split(" "),function(A,m,H,r,B,q,v,I,J,l,w,C,x,K){function L(e){switch(e.componentType){case 5120:return new l.BufferViewVec2i8(e.raw,e.byteOffset,
e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5121:return new l.BufferViewVec2u8(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5122:return new l.BufferViewVec2i16(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5123:return new l.BufferViewVec2u16(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5125:return new l.BufferViewVec2u32(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);
case 5126:return new l.BufferViewVec2f(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);default:H.neverReached(e.componentType)}}function M(e){return y.apply(this,arguments)}function y(){y=m._asyncToGenerator(function*(e){return new Promise((k,d)=>{const a=new Blob([e]),b=new FileReader;b.onload=()=>{k(JSON.parse(b.result))};b.onerror=c=>{d(c)};b.readAsText(a)})});return y.apply(this,arguments)}function N(e,k){return z.apply(this,arguments)}function z(){z=m._asyncToGenerator(function*(e,
k){return new Promise((d,a)=>{const b=new Blob([e],{type:k}),c=URL.createObjectURL(b),f=new Image;f.addEventListener("load",()=>{URL.revokeObjectURL(c);"decode"in f?f.decode().then(()=>d(f),()=>d(f)):d(f)});f.addEventListener("error",g=>{URL.revokeObjectURL(c);a(g)});f.src=c})});return z.apply(this,arguments)}let S=function(){function e(d,a,b,c,f){this.context=d;this.errorContext=a;this.uri=b;this.json=c;this.glbBuffer=f;this.bufferCache=new Map;this.textureCache=new Map;this.materialCache=new Map;
this.nodeParentMap=new Map;this.nodeTransformCache=new Map;this.baseUri=K.splitURI(this.uri).dirPart;this.checkVersionSupported();this.checkRequiredExtensionsSupported();a.errorUnsupportedIf(null==c.scenes,"Scenes must be defined.");a.errorUnsupportedIf(null==c.meshes,"Meshes must be defined");a.errorUnsupportedIf(null==c.nodes,"Nodes must be defined.");this.computeNodeParents()}e.load=function(){var d=m._asyncToGenerator(function*(a,b,c,f){if(r.isDataProtocol(c)){var g=r.dataComponents(c);if("model/gltf-binary"!==
g.mediaType)try{const h=JSON.parse(g.isBase64?atob(g.data):g.data);return new e(a,b,c,h)}catch{}g=r.dataToArrayBuffer(c);if(e.isGLBData(g))return this.fromGLBData(a,b,c,g)}if(c.endsWith(".gltf"))return f=yield a.loadJSON(c,f),new e(a,b,c,f);g=yield a.loadBinary(c,f);if(e.isGLBData(g))return this.fromGLBData(a,b,c,g);f=yield a.loadJSON(c,f);return new e(a,b,c,f)});return function(a,b,c,f){return d.apply(this,arguments)}}();e.isGLBData=function(d){d=new C.BinaryStreamReader(d);return 4<=d.remainingBytes()&&
1179937895===d.readUint32()};e.fromGLBData=function(){var d=m._asyncToGenerator(function*(a,b,c,f){f=yield e.parseGLBData(b,f);return new e(a,b,c,f.json,f.binaryData)});return function(a,b,c,f){return d.apply(this,arguments)}}();e.parseGLBData=function(){var d=m._asyncToGenerator(function*(a,b){const c=new C.BinaryStreamReader(b);a.assert(12<=c.remainingBytes(),"GLB binary data is insufficiently large.");var f=c.readUint32(),g=c.readUint32();const h=c.readUint32();a.assert(1179937895===f,"Magic first 4 bytes do not fit to expected GLB value.");
a.assert(b.byteLength>=h,"GLB binary data is smaller than header specifies.");a.errorUnsupportedIf(2!==g,"An unsupported GLB container version was detected. Only version 2 is supported.");b=0;let n,p;for(;8<=c.remainingBytes();)f=c.readUint32(),g=c.readUint32(),0===b?(a.assert(1313821514===g,"First GLB chunk must be JSON."),a.assert(0<=f,"No JSON data found."),n=yield M(c.readUint8Array(f))):1===b?(a.errorUnsupportedIf(5130562!==g,"Second GLB chunk expected to be BIN."),p=c.readUint8Array(f)):a.warnUnsupported("More than 2 GLB chunks detected. Skipping."),
b+=1;n||a.error("No GLB JSON chunk detected.");return{json:n,binaryData:p}});return function(a,b){return d.apply(this,arguments)}}();var k=e.prototype;k.getBuffer=function(){var d=m._asyncToGenerator(function*(a,b){const c=this.json.buffers[a],f=this.errorContext;if(null==c.uri)return f.assert(null!=this.glbBuffer,"GLB buffer not present"),this.glbBuffer;let g=this.bufferCache.get(a);g||(b=yield this.context.loadBinary(this.resolveUri(c.uri),b),g=new Uint8Array(b),this.bufferCache.set(a,g),f.assert(g.byteLength===
c.byteLength,"Buffer byte lengths should match."));return g});return function(a,b){return d.apply(this,arguments)}}();k.getAccessor=function(){var d=m._asyncToGenerator(function*(a,b){a=this.json.accessors[a];var c=this.errorContext;c.errorUnsupportedIf(null==a.bufferView,"Some accessor does not specify a bufferView.");c.errorUnsupportedIf(a.type in["MAT2","MAT3","MAT4"],`AttributeType ${a.type} is not supported`);c=this.json.bufferViews[a.bufferView];b=yield this.getBuffer(c.buffer,b);const f=O[a.type],
g=P[a.componentType],h=f*g,n=c.byteStride||h;return{raw:b.buffer,byteStride:n,byteOffset:b.byteOffset+(c.byteOffset||0)+(a.byteOffset||0),entryCount:a.count,isDenselyPacked:n===h,componentCount:f,componentByteSize:g,componentType:a.componentType,min:a.min,max:a.max,normalized:!!a.normalized}});return function(a,b){return d.apply(this,arguments)}}();k.getIndexData=function(){var d=m._asyncToGenerator(function*(a,b){if(null==a.indices)return null;a=yield this.getAccessor(a.indices,b);if(a.isDenselyPacked)switch(a.componentType){case 5121:return new Uint8Array(a.raw,
a.byteOffset,a.entryCount);case 5123:return new Uint16Array(a.raw,a.byteOffset,a.entryCount);case 5125:return new Uint32Array(a.raw,a.byteOffset,a.entryCount)}else switch(a.componentType){case 5121:return w.makeDense(this.wrapAccessor(l.BufferViewUint8,a));case 5123:return w.makeDense(this.wrapAccessor(l.BufferViewUint16,a));case 5125:return w.makeDense(this.wrapAccessor(l.BufferViewUint32,a))}});return function(a,b){return d.apply(this,arguments)}}();k.getPositionData=function(){var d=m._asyncToGenerator(function*(a,
b){const c=this.errorContext;c.errorUnsupportedIf(null==a.attributes.POSITION,"No POSITION vertex data found.");a=yield this.getAccessor(a.attributes.POSITION,b);c.errorUnsupportedIf(5126!==a.componentType,"Expected type FLOAT for POSITION vertex attribute, but found "+t[a.componentType]);c.errorUnsupportedIf(3!==a.componentCount,"POSITION vertex attribute must have 3 components, but found "+a.componentCount.toFixed());return this.wrapAccessor(l.BufferViewVec3f,a)});return function(a,b){return d.apply(this,
arguments)}}();k.getNormalData=function(){var d=m._asyncToGenerator(function*(a,b){const c=this.errorContext;c.assert(null!=a.attributes.NORMAL,"No NORMAL vertex data found.");a=yield this.getAccessor(a.attributes.NORMAL,b);c.errorUnsupportedIf(5126!==a.componentType,"Expected type FLOAT for NORMAL vertex attribute, but found "+t[a.componentType]);c.errorUnsupportedIf(3!==a.componentCount,"NORMAL vertex attribute must have 3 components, but found "+a.componentCount.toFixed());return this.wrapAccessor(l.BufferViewVec3f,
a)});return function(a,b){return d.apply(this,arguments)}}();k.getTangentData=function(){var d=m._asyncToGenerator(function*(a,b){const c=this.errorContext;c.assert(null!=a.attributes.TANGENT,"No TANGENT vertex data found.");a=yield this.getAccessor(a.attributes.TANGENT,b);c.errorUnsupportedIf(5126!==a.componentType,"Expected type FLOAT for TANGENT vertex attribute, but found "+t[a.componentType]);c.errorUnsupportedIf(4!==a.componentCount,"TANGENT vertex attribute must have 4 components, but found "+
a.componentCount.toFixed());return new l.BufferViewVec4f(a.raw,a.byteOffset,a.byteStride,a.byteOffset+a.byteStride*a.entryCount)});return function(a,b){return d.apply(this,arguments)}}();k.getTextureCoordinates=function(){var d=m._asyncToGenerator(function*(a,b){const c=this.errorContext;c.assert(null!=a.attributes.TEXCOORD_0,"No TEXCOORD_0 vertex data found.");a=yield this.getAccessor(a.attributes.TEXCOORD_0,b);c.errorUnsupportedIf(2!==a.componentCount,"TEXCOORD_0 vertex attribute must have 2 components, but found "+
a.componentCount.toFixed());if(5126===a.componentType)return this.wrapAccessor(l.BufferViewVec2f,a);c.errorUnsupportedIf(!a.normalized,"Integer component types are only supported for a normalized accessor for TEXCOORD_0.");return L(a)});return function(a,b){return d.apply(this,arguments)}}();k.getVertexColors=function(){var d=m._asyncToGenerator(function*(a,b){const c=this.errorContext;c.assert(null!=a.attributes.COLOR_0,"No COLOR_0 vertex data found.");a=yield this.getAccessor(a.attributes.COLOR_0,
b);c.errorUnsupportedIf(4!==a.componentCount&&3!==a.componentCount,"COLOR_0 attribute must have 3 or 4 components, but found "+a.componentCount.toFixed());if(4===a.componentCount){if(5126===a.componentType)return this.wrapAccessor(l.BufferViewVec4f,a);if(5121===a.componentType)return this.wrapAccessor(l.BufferViewVec4u8,a);if(5123===a.componentType)return this.wrapAccessor(l.BufferViewVec4u16,a)}else if(3===a.componentCount){if(5126===a.componentType)return this.wrapAccessor(l.BufferViewVec3f,a);
if(5121===a.componentType)return this.wrapAccessor(l.BufferViewVec3u8,a);if(5123===a.componentType)return this.wrapAccessor(l.BufferViewVec3u16,a)}c.errorUnsupported("Unsupported component type for COLOR_0 attribute: "+t[a.componentType])});return function(a,b){return d.apply(this,arguments)}}();k.hasPositions=function(d){return void 0!==d.attributes.POSITION};k.hasNormals=function(d){return void 0!==d.attributes.NORMAL};k.hasVertexColors=function(d){return void 0!==d.attributes.COLOR_0};k.hasTextureCoordinates=
function(d){return void 0!==d.attributes.TEXCOORD_0};k.hasTangents=function(d){return void 0!==d.attributes.TANGENT};k.getMaterial=function(){var d=m._asyncToGenerator(function*(a,b,c){const f=this.errorContext;var g=this.materialCache.get(a.material);if(!g){g=null!=a.material?x.material(this.json.materials[a.material]):x.material();const h=g.pbrMetallicRoughness,n=this.hasVertexColors(a);let p;h.baseColorTexture&&(f.errorUnsupportedIf(0!==(h.baseColorTexture.texCoord||0),"Only TEXCOORD with index 0 is supported."),
p=yield this.getTexture(h.baseColorTexture.index,b));let D;g.normalTexture&&(0!==(g.normalTexture.texCoord||0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the normal map texture."):D=yield this.getTexture(g.normalTexture.index,b));let E;g.occlusionTexture&&c&&(0!==(g.occlusionTexture.texCoord||0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the occlusion texture."):E=yield this.getTexture(g.occlusionTexture.index,b));let F;g.emissiveTexture&&c&&(0!==(g.emissiveTexture.texCoord||
0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the emissive texture."):F=yield this.getTexture(g.emissiveTexture.index,b));let G;h.metallicRoughnessTexture&&c&&(0!==(h.metallicRoughnessTexture.texCoord||0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the metallicRoughness texture."):G=yield this.getTexture(h.metallicRoughnessTexture.index,b));g={alphaMode:g.alphaMode,alphaCutoff:g.alphaCutoff,color:h.baseColorFactor,doubleSided:!!g.doubleSided,colorTexture:p,normalTexture:D,
name:g.name,id:null!=a.material?a.material:-1,occlusionTexture:E,emissiveTexture:F,emissiveFactor:g.emissiveFactor,metallicFactor:h.metallicFactor,roughnessFactor:h.roughnessFactor,metallicRoughnessTexture:G,vertexColors:n,ESRI_externalColorMixMode:g.extras.ESRI_externalColorMixMode}}return g});return function(a,b,c){return d.apply(this,arguments)}}();k.getTexture=function(){var d=m._asyncToGenerator(function*(a,b){const c=this.errorContext;var f=this.json.textures[a];const g=x.textureSampler(null!=
f.sampler?this.json.samplers[f.sampler]:{});c.errorUnsupportedIf(null==f.source,"Source is expected to be defined for a texture.");f=this.json.images[f.source];var h=this.textureCache.get(a);if(!h){f.uri?b=yield this.context.loadImage(this.resolveUri(f.uri),b):(c.errorUnsupportedIf(null==f.bufferView,"Image bufferView must be defined."),c.errorUnsupportedIf(null==f.mimeType,"Image mimeType must be defined."),h=this.json.bufferViews[f.bufferView],b=yield this.getBuffer(h.buffer,b),c.errorUnsupportedIf(null!=
h.byteStride,"byteStride not supported for image buffer"),b=yield N(new Uint8Array(b.buffer,b.byteOffset+(h.byteOffset||0),h.byteLength),f.mimeType));h=p=>33071===p||33648===p||10497===p;const n=p=>{c.error(`Unexpected TextureSampler WrapMode: ${p}. Using default REPEAT(10497).`);return 10497};h={data:b,wrapS:h(g.wrapS)?g.wrapS:n(g.wrapS),wrapT:h(g.wrapT)?g.wrapT:n(g.wrapT),minFilter:g.minFilter,name:f.name,id:a};this.textureCache.set(a,h)}return h});return function(a,b){return d.apply(this,arguments)}}();
k.getNodeTransform=function(d){if(void 0===d)return Q;var a=this.nodeTransformCache.get(d);if(!a){a=this.getNodeTransform(this.getNodeParent(d));const b=this.json.nodes[d];if(b.matrix)a=q.multiply(v.create(),a,b.matrix);else if(b.translation||b.rotation||b.scale)a=v.clone(a),b.translation&&q.translate(a,a,b.translation),b.rotation&&(u[3]=I.getAxisAngle(u,b.rotation),q.rotate(a,a,u[3],u)),b.scale&&q.scale(a,a,b.scale);this.nodeTransformCache.set(d,a)}return a};k.wrapAccessor=function(d,a){return new d(a.raw,
a.byteOffset,a.byteStride,a.byteOffset+a.byteStride*(a.entryCount-1)+a.componentByteSize*a.componentCount)};k.resolveUri=function(d){return r.makeAbsolute(d,this.baseUri)};k.getNodeParent=function(d){return this.nodeParentMap.get(d)};k.checkVersionSupported=function(){const d=B.Version.parse(this.json.asset.version,"glTF");R.validate(d)};k.checkRequiredExtensionsSupported=function(){const d=this.json,a=this.errorContext;d.extensionsRequired&&0!==d.extensionsRequired.length&&a.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: "+
d.extensionsRequired.join(", "))};k.computeNodeParents=function(){this.json.nodes.forEach((d,a)=>{d.children&&d.children.forEach(b=>{this.nodeParentMap.set(b,a)})})};return e}();const R=new B.Version(2,0,"glTF"),Q=q.fromXRotation(v.create(),Math.PI/2),u=J.create(),O={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},P={[5120]:1,[5121]:1,[5122]:2,[5123]:2,[5126]:4,[5125]:4},t={5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5125:"UNSIGNED_INT",5126:"FLOAT"};A.Resource=S;Object.defineProperty(A,"__esModule",
{value:!0})});