// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/centroid ../../../../geometry/support/jsonUtils ../../../../geometry/support/quantizationUtils ../../../../layers/graphics/featureConversionUtils ../../../../layers/graphics/OptimizedGeometry ./graphicsUtils".split(" "),function(w,x,u,y,n,p,q,g,r){function v(c){c.coords.length=0;c.lengths.length=0}const h=new g,t=new g;g=function(){function c(){this.bounds=
u.create();this.graphic=null;this.size=[0,0,0,0]}c.acquire=function(b=null,d,a,e,f,k){let l;0===c._pool.length?l=new c:(l=c._pool.pop(),this._set.delete(l));l.acquire(b,d,a,e,f,k);return l};c.release=function(b){b&&!this._set.has(b)&&(b.release(),this._pool.push(b),this._set.add(b))};c.getCentroidQuantized=function(b,d){if(n.isPolygon(b.geometry)){const a=b.symbol;if(x.isNone(a))return null;if(r.isMarkerSymbol(a.type)||r.isTextSymbol(a.type))return b=y.polygonCentroid(b.geometry),p.quantizePoint(d,
{},{x:b[0],y:b[1]},!1,!1)}return null};var m=c.prototype;m.acquire=function(b=null,d,a,e,f,k){b&&this.set(b,d,a,e,f,k)};m.release=function(){this.geometry=this.symbolResource=this.graphic=null};m.set=function(b,d,a,e,f,k){this.graphic=b;this.geometry=a;this.symbolResource=d;this.resolution=e;this.updateBounds(e,f,k)};m.updateBounds=function(b,d,a){r.getBounds(this.bounds,this.size,this.symbolResource,this.geometry,b,d,a)};m.getGeometryQuantized=function(b,d){var a=this.geometry;if(n.isPolygon(a)){if(a=
a.rings,1===a.length&&2===a[0].length)return p.quantizeGeometry(b,{paths:[[a[0][0],a[0][1]]]})}else{if(n.isPolyline(a))return v(h),v(t),q.convertFromPolyline(h,a),q.generalizeOptimizedGeometry(t,h,a.hasZ,a.hasM,"esriGeometryPolyline",b.scale[0]),q.quantizeOptimizedGeometry(h,t,a.hasZ,a.hasM,"esriGeometryPolyline",b),q.convertToPolyline(h,a.hasZ,a.hasM);if(n.isMultipoint(a)){const e=.5*this.resolution*this.size[0];a=a.points.filter(f=>u.containsPointWithMargin(d,f,e));return 0===a.length?{points:a}:
p.quantizeGeometry(b,{points:a})}}return p.quantizeGeometry(b,this.geometry)};w._createClass(c,[{key:"symbol",get:function(){return this.symbolResource.symbol}}]);return c}();g._pool=[];g._set=new Set;return g});