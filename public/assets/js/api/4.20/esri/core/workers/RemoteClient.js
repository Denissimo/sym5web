// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("../../kernel ../Error ../events ../maybe ../promiseUtils ./registry ./utils ../../support/revision".split(" "),function(B,v,C,D,r,E,k,w){const {CLOSE:x,ABORT:y,INVOKE:z,RESPONSE:t,OPEN_PORT:A,ON:F}=k.MessageType;let G=function(){function h(a){this._timer=null;this._cancelledJobIds=new Set;this._invokeMessages=[];this._invoke=a;this._timer=null;this._process=this._process.bind(this)}var e=h.prototype;e.push=function(a){a.type===k.MessageType.ABORT?this._cancelledJobIds.add(a.jobId):(this._invokeMessages.push(a),
null===this._timer&&(this._timer=setTimeout(this._process,0)))};e.clear=function(){this._invokeMessages.length=0;this._cancelledJobIds.clear();this._timer=null};e._process=function(){this._timer=null;for(const a of this._invokeMessages)this._cancelledJobIds.has(a.jobId)||this._invoke(a);this._cancelledJobIds.clear();this._invokeMessages.length=0};return h}(),u=function(){function h(a,b){this._port=a;this._outJobs=new Map;this._inJobs=new Map;this._invokeQueue=new G(c=>this._onInvokeMessage(c));this._client=
b.client;this._onMessage=this._onMessage.bind(this);this._channel=b.channel;this._schedule=b.schedule;this._port.addEventListener("message",this._onMessage);this._port.start()}h.connect=function(a){const b=new MessageChannel;a="function"===typeof a?new a:"default"in a&&"function"===typeof a.default?new a.default:a;const c=new h(b.port1,{channel:b,client:a});"object"===typeof a&&"remoteClient"in a&&(a.remoteClient=c);h.clients.set(c,a);return b.port2};h.loadWorker=function(a){return(a=E.registry[a])?
a():Promise.resolve(null)};var e=h.prototype;e.close=function(){this._post({type:x});this._close()};e.isBusy=function(){return 0<this._outJobs.size};e.invoke=function(a,b,c){const d=c&&c.signal,l=c&&c.transferList;if(!this._port)return Promise.reject(new v("worker:port-closed",`Cannot call invoke('${a}'), port is closed`,{methodName:a,data:b}));const f=k.newJobId();return new Promise((m,n)=>{const q=r.onAbortOrThrow(d,()=>{var g;const p=this._outJobs.get(f);p&&(this._outJobs.delete(f),null==(g=p.abortHandle)?
void 0:g.remove(),this._post({type:y,jobId:f}),n(r.createAbortError()))});this._outJobs.set(f,{resolve:m,reject:n,abortHandle:q,debugInfo:a});this._post({type:z,jobId:f,methodName:a,abortable:null!=d},b,l)})};e.on=function(a,b){function c(l){b(l.data)}const d=new MessageChannel;this._port.postMessage({type:k.MessageType.ON,eventType:a,port:d.port2},[d.port2]);d.port1.addEventListener("message",c);d.port1.start();return{remove(){d.port1.postMessage({type:k.MessageType.CLOSE});d.port1.close();d.port1.removeEventListener("message",
c)}}};e.openPort=function(){const a=new MessageChannel;this._post({type:A,port:a.port2});return a.port1};e._close=function(){this._channel&&(this._channel=null);this._port.removeEventListener("message",this._onMessage);this._port.close();this._outJobs.forEach(a=>{var b;null==(b=a.abortHandle)?void 0:b.remove();a.reject(r.createAbortError(`Worker closing, aborting job calling '${a.debugInfo}'`))});this._inJobs.clear();this._outJobs.clear();this._invokeQueue.clear();this._port=this._client=this._schedule=
null};e._onMessage=function(a){D.isSome(this._schedule)?this._schedule(()=>this._processMessage(a)):this._processMessage(a)};e._processMessage=function(a){if(a=k.receiveMessage(a))switch(a.type){case t:this._onResponseMessage(a);break;case z:this._invokeQueue.push(a);break;case y:this._onAbortMessage(a);break;case x:this._onCloseMessage();break;case A:this._onOpenPortMessage(a);break;case F:this._onOnMessage(a)}};e._onAbortMessage=function(a){const b=this._inJobs,c=a.jobId,d=b.get(c);this._invokeQueue.push(a);
d&&(d.controller&&d.controller.abort(),b.delete(c))};e._onCloseMessage=function(){const a=this._client;this._close();a&&"destroy"in a&&h.clients.get(this)===a&&a.destroy();h.clients.delete(this);a&&a.remoteClient&&(a.remoteClient=null)};e._onInvokeMessage=function(a){const {methodName:b,jobId:c,data:d,abortable:l}=a;a=l?r.createAbortController():null;const f=this._inJobs;let m=this._client,n=m[b],q;try{if(!n&&b&&-1!==b.indexOf(".")){const g=b.split(".");for(let p=0;p<g.length-1;p++)m=m[g[p]],n=m[g[p+
1]]}if("function"!==typeof n)throw new TypeError(`${b} is not a function`);q=n.call(m,d,{client:this,signal:a?a.signal:null})}catch(g){this._post({type:t,jobId:c,error:k.toInvokeError(g)});return}r.isPromiseLike(q)?(f.set(c,{controller:a,promise:q}),q.then(g=>{f.has(c)&&(f.delete(c),this._post({type:t,jobId:c},g))},g=>{f.has(c)&&(f.delete(c),r.isAbortError(g)||this._post({type:t,jobId:c,error:k.toInvokeError(g||{message:`Error encountered at method ${b}`})}))})):this._post({type:t,jobId:c},q)};e._onOpenPortMessage=
function(a){new h(a.port,{client:this._client})};e._onOnMessage=function(a){const {port:b}=a,c=this._client.on(a.eventType,l=>{b.postMessage(l)}),d=C.on(a.port,"message",l=>{k.receiveMessage(l).type===k.MessageType.CLOSE&&(d.remove(),c.remove(),b.close())})};e._onResponseMessage=function(a){var b;const {jobId:c,error:d,data:l}=a;a=this._outJobs;if(a.has(c)){var f=a.get(c);a.delete(c);null==(b=f.abortHandle)?void 0:b.remove();d?f.reject(v.fromJSON(JSON.parse(d))):f.resolve(l)}};e._post=function(a,
b,c){return k.postMessage(this._port,a,b,c)};return h}();u.kernelInfo={revision:w.commitHash,version:B.version,buildDate:w.buildDate};u.clients=new Map;return u});