// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.20/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Graphic ../../core/Collection ../../core/Error ../../core/HandleOwner ../../core/maybe ../../core/watchUtils ../../core/accessorSupport/decorators/property ../../core/has ../../core/accessorSupport/decorators/cast ../../core/Logger ../../core/jsonMap ../../core/accessorSupport/decorators/subclass ../../rest/query/support/AttachmentInfo ../../rest/support/AttachmentQuery ../Feature/support/featureUtils".split(" "),function(l,
k,x,f,g,y,z,A,p,G,B,H,I,C,D,t,E){const u={editing:!1,operations:{add:!0,update:!0,delete:!0}},v=f.ofType(D);f=function(w){function q(b){var a=w.call(this,b)||this;a._getAttachmentsPromise=null;a._attachmentLayer=null;a.abilities={...u};a.activeAttachmentInfo=null;a.attachmentInfos=new v;a.graphic=null;a.mode="view";a.handles.add([A.init(l._assertThisInitialized(a),"graphic",()=>a._graphicChanged())]);return a}l._inheritsLoose(q,w);var h=q.prototype;h.destroy=function(){this.graphic=this._attachmentLayer=
null};h.castAbilities=function(b){return{...u,...b}};h.getAttachments=function(){var b=l._asyncToGenerator(function*(){const {_attachmentLayer:a,attachmentInfos:c}=this;if(!a||"function"!==typeof a.queryAttachments)throw new g("invalid-layer","getAttachments(): A valid layer is required.");const d=this._getFeatureId();var e=new t({objectIds:[d],returnMetadata:!0});const m=[];this._getAttachmentsPromise=e=a.queryAttachments(e).then(n=>n[d]||m).catch(()=>m);this.notifyChange("state");e=yield e;c.removeAll();
e.length&&c.addMany(e);this._getAttachmentsPromise=null;this.notifyChange("state");return e});return function(){return b.apply(this,arguments)}}();h.addAttachment=function(){var b=l._asyncToGenerator(function*(a){const {_attachmentLayer:c,attachmentInfos:d,graphic:e,abilities:m}=this;if(!a)throw new g("invalid-attachment","addAttachment(): An attachment is required.",{attachment:a});if(!m.operations.add)throw new g("invalid-abilities","addAttachment(): add abilities are required.");if(!c||"function"!==
typeof c.addAttachment)throw new g("invalid-layer","addAttachment(): A valid layer is required.");a=yield c.addAttachment(e,a).then(n=>this._queryAttachment(n.objectId));d.add(a);return a});return function(a){return b.apply(this,arguments)}}();h.deleteAttachment=function(){var b=l._asyncToGenerator(function*(a){const {_attachmentLayer:c,attachmentInfos:d,graphic:e,abilities:m}=this;if(!a)throw new g("invalid-attachment-info","deleteAttachment(): An attachmentInfo is required.",{attachmentInfo:a});
if(!m.operations.delete)throw new g("invalid-abilities","deleteAttachment(): delete abilities are required.");if(!c||"function"!==typeof c.deleteAttachments)throw new g("invalid-layer","deleteAttachment(): A valid layer is required.");const n=yield c.deleteAttachments(e,[a.id]).then(()=>a);d.remove(n);return n});return function(a){return b.apply(this,arguments)}}();h.updateAttachment=function(){var b=l._asyncToGenerator(function*(a,c=this.activeAttachmentInfo){const {_attachmentLayer:d,attachmentInfos:e,
graphic:m,abilities:n}=this;if(!a)throw new g("invalid-attachment","updateAttachment(): An attachment is required.",{attachment:a});if(!c)throw new g("invalid-attachment-info","updateAttachment(): An attachmentInfo is required.",{attachmentInfo:c});if(!n.operations.update)throw new g("invalid-abilities","updateAttachment(): Update abilities are required.");const F=e.findIndex(r=>r===c);if(!d||"function"!==typeof d.updateAttachment)throw new g("invalid-layer","updateAttachment(): A valid layer is required.");
a=yield d.updateAttachment(m,c.id,a).then(r=>this._queryAttachment(r.objectId));e.splice(F,1,a);return a});return function(a){return b.apply(this,arguments)}}();h._queryAttachment=function(){var b=l._asyncToGenerator(function*(a){if(!a)throw new g("invalid-attachment-id","Could not query attachment.");const {_attachmentLayer:c}=this,d=this._getFeatureId();a=new t({objectIds:[d],attachmentsWhere:`AttachmentId=${a}`,returnMetadata:!0});return c.queryAttachments(a).then(e=>e[d][0])});return function(a){return b.apply(this,
arguments)}}();h._getFeatureId=function(){const {_attachmentLayer:b,graphic:a}=this;if(!b||!a)return null;const {objectIdField:c}=b,{attributes:d}=a;return d&&d[c]};h._graphicChanged=function(){this.graphic&&(this._setAttachmentLayer(),this.getAttachments().catch(()=>{}))};h._setAttachmentLayer=function(){var {graphic:b}=this;this._attachmentLayer=(b=E.getSourceLayer(b))?"scene"===b.type&&z.isSome(b.associatedLayer)?b.associatedLayer:b:null};l._createClass(q,[{key:"state",get:function(){return this._getAttachmentsPromise?
"loading":this.graphic?"ready":"disabled"}},{key:"supportsResizeAttachments",get:function(){return this.get("graphic.layer.capabilities.operations.supportsResizeAttachments")||!1}}]);return q}(y.HandleOwner);k.__decorate([p.property()],f.prototype,"abilities",void 0);k.__decorate([B.cast("abilities")],f.prototype,"castAbilities",null);k.__decorate([p.property()],f.prototype,"activeAttachmentInfo",void 0);k.__decorate([p.property({readOnly:!0,type:v})],f.prototype,"attachmentInfos",void 0);k.__decorate([p.property({type:x})],
f.prototype,"graphic",void 0);k.__decorate([p.property()],f.prototype,"mode",void 0);k.__decorate([p.property({readOnly:!0})],f.prototype,"state",null);k.__decorate([p.property({readOnly:!0})],f.prototype,"supportsResizeAttachments",null);return f=k.__decorate([C.subclass("esri.widgets.Attachments.AttachmentsViewModel")],f)});