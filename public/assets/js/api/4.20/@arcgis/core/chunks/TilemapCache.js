/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../request.js";import i from"../core/Accessor.js";import l from"../core/Error.js";import a from"../core/Handles.js";import{L as r}from"./Logger.js";import{L as s}from"./LRUCache.js";import{P as o,waitTicks as n}from"../core/scheduling.js";import{onAbort as h,createAbortError as c,isAbortError as p,createAbortController as m,isAborted as f}from"../core/promiseUtils.js";import{objectToQuery as u}from"../core/urlUtils.js";import{init as v}from"../core/watchUtils.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import{clone as y}from"../core/lang.js";import{cast as b}from"../core/accessorSupport/decorators/cast.js";import{subclass as w}from"../core/accessorSupport/decorators/subclass.js";import{c as _}from"./arrayUtils.js";class g{constructor(){this.location={left:0,top:0,width:0,height:0},this._allAvailability="unknown",this.byteSize=40}getAvailability(e,t){if("unknown"!==this._allAvailability)return this._allAvailability;const i=(e-this.location.top)*this.location.width+(t-this.location.left),l=i%8,a=i>>3,r=this._tileAvailabilityBitSet;return a<0||a>r.length?"unknown":r[a]&1<<l?"available":"unavailable"}_updateFromData(e){const t=this.location.width,i=this.location.height;let l=!0,a=!0;const r=Math.ceil(t*i/8),s=new Uint8Array(r);let o=0;for(let t=0;t<e.length;t++){const i=t%8;e[t]?(a=!1,s[o]|=1<<i):l=!1,7===i&&++o}a?this._allAvailability="unavailable":l?this._allAvailability="available":(this._allAvailability="unknown",this._tileAvailabilityBitSet=s,this.byteSize+=s.length)}static fromDefinition(e,i){const a=e.service.request||t,{row:r,col:s,width:o,height:n}=e,h={query:{f:"json"}};return i=i?{...h,...i}:h,a(function(e){let t;if("vector-tile"===e.service.type)t=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;else{const i=e.service.tileServers;t=`${i&&i.length?i[e.row%i.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}const i=e.service.query;i&&(t=`${t}?${i}`);return t}(e),i).then((e=>e.data)).catch((e=>{if(e&&e.details&&422===e.details.httpStatus)return{location:{top:r,left:s,width:o,height:n},valid:!0,data:_(o*n,0)};throw e})).then((e=>{if(e.location&&(e.location.top!==r||e.location.left!==s||e.location.width!==o||e.location.height!==n))throw new l("tilemap:location-mismatch","Tilemap response for different location than requested",{response:e,definition:{top:r,left:s,width:o,height:n}});return g.fromJSON(e)}))}static fromJSON(e){g.validateJSON(e);const t=new g;return t.location=Object.freeze(y(e.location)),t._updateFromData(e.data),Object.freeze(t)}static validateJSON(e){if(!e||!e.location)throw new l("tilemap:missing-location","Location missing from tilemap response");if(!1===e.valid)throw new l("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new l("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new l("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new l("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function A(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}var T;const j=r.getLogger("esri.layers.support.TilemapCache");let $=T=class extends i{constructor(e){super(e),this._handles=new a,this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2097152,this.request=t,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new s(this.cacheByteSize),this._handles.add([this.watch(["layer.parsedUrl","layer.tileServers?"],(()=>this._initializeTilemapDefinition())),v(this,"layer.tileInfo.lods",(e=>this._initializeAvailableLevels(e)),!0)]),this._initializeTilemapDefinition()}destroy(){this._handles&&(this._handles.destroy(),this._handles=null)}castLevels(e){return e<=2?(j.error("Minimum levels for Tilemap is 3, but got ",e),3):e}get size(){return 1<<this.levels}fetchTilemap(e,t,i,a){if(!this._availableLevels[e])return Promise.reject(new l("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const r=this._tmpTilemapDefinition,s=this._tilemapFromCache(e,t,i,r);if(s)return Promise.resolve(s);const o=a&&a.signal;return a={...a,signal:null},new Promise(((e,t)=>{h(o,(()=>t(c())));const i=A(r);let l=this._pendingTilemapRequests[i];if(!l){l=g.fromDefinition(r,a).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=l,l.then(e,e)}l.then(e,t)}))}getAvailability(e,t,i){if(!this._availableLevels[e])return"unavailable";const l=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return l?l.getAvailability(t,i):"unknown"}getAvailabilityUpsample(e,t,i,l){l.level=e,l.row=t,l.col=i;const a=this.layer.tileInfo;for(a.updateTileInfo(l);;){const e=this.getAvailability(l.level,l.row,l.col);if("unavailable"!==e)return e;if(!a.upsampleTile(l))return"unavailable"}}fetchAvailability(e,t,i,a){return this._availableLevels[e]?this.fetchTilemap(e,t,i,a).catch((e=>e)).then((a=>{if(a instanceof g){const r=a.getAvailability(t,i);return"unavailable"===r?Promise.reject(new l("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i})):r}if(p(a))throw a;return"unknown"})):Promise.reject(new l("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`))}fetchAvailabilityUpsample(e,t,i,l,a){l.level=e,l.row=t,l.col=i;const r=this.layer.tileInfo;r.updateTileInfo(l);const s=this.fetchAvailability(e,t,i,a).catch((e=>{if(p(e))throw e;if(r.upsampleTile(l))return this.fetchAvailabilityUpsample(l.level,l.row,l.col,l);throw e}));return this._fetchAvailabilityUpsamplePrefetch(l.id,e,t,i,a,s),s}async _fetchAvailabilityUpsamplePrefetch(e,t,i,l,a,r){if(!this._prefetchingEnabled)return;const s=`prefetch-${e}`;if(this._handles.has(s))return;const o=m();r.then((()=>o.abort()),(()=>o.abort()));let h=!1;const c={remove(){h||(h=!0,o.abort())}};if(this._handles.add(c,s),await n(10,o.signal).catch((()=>{})),h||(h=!0,this._handles.remove(s)),f(o))return;const p={id:e,level:t,row:i,col:l},u={...a,signal:o.signal},v=this.layer.tileInfo;for(let e=0;T._prefetches.length<T._maxPrefetch&&v.upsampleTile(p);++e){const e=this.fetchAvailability(p.level,p.row,p.col,u);T._prefetches.push(e);const t=()=>{T._prefetches.removeUnordered(e)};e.then(t,t)}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const e=this.layer.parsedUrl,t=e.query;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:t?u(t):null,tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,i,l){l.level=e,l.row=t-t%this.size,l.col=i-i%this.size;const a=A(l);return this._tilemapCache.get(a)}_initializeAvailableLevels(e){this._availableLevels={},e&&e.forEach((e=>this._availableLevels[e.level]=!0))}get test(){const e=this;return{get prefetchingEnabled(){return e._prefetchingEnabled},set prefetchingEnabled(t){e._prefetchingEnabled=t},hasTilemap:(t,i,l)=>!!e._tilemapFromCache(t,i,l,e._tmpTilemapDefinition)}}};$._maxPrefetch=4,$._prefetches=new o({initialSize:T._maxPrefetch}),e([d({constructOnly:!0,type:Number})],$.prototype,"levels",void 0),e([b("levels")],$.prototype,"castLevels",null),e([d({readOnly:!0,type:Number})],$.prototype,"size",null),e([d({constructOnly:!0,type:Number})],$.prototype,"cacheByteSize",void 0),e([d({constructOnly:!0})],$.prototype,"layer",void 0),e([d({constructOnly:!0})],$.prototype,"request",void 0),$=T=e([w("esri.layers.support.TilemapCache")],$);export{$ as T};
