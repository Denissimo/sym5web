/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../core/Accessor.js";import{debounce as i}from"../core/promiseUtils.js";import{property as o}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./ensureType.js";import"./Logger.js";import{subclass as r}from"../core/accessorSupport/decorators/subclass.js";import s from"../geometry/Extent.js";import{a}from"./aaBoundingRect.js";import{g as n}from"../geometry/SpatialReference.js";import p from"../layers/support/TileInfo.js";import{B as m}from"./Bitmap.js";import{T as h}from"./TileInfoView.js";import{T as d}from"./TileKey.js";const l=Math.PI/180;function c(t,e){const i=e.rotation*l;const o=Math.abs(Math.cos(i)),r=Math.abs(Math.sin(i)),[s,a]=e.size;return t[0]=Math.round(a*r+s*o),t[1]=Math.round(a*o+s*r),t}const u=a(),g=[0,0],f=new d(0,0,0,0),x=2048,y=2048,M=!1,v=!1,S=!1;let w=class extends e{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=S,this.imageMaxWidth=x,this.imageMaxHeight=y,this.imageRotationSupported=M,this.imageNormalizationSupported=v,this.update=i((async(t,e)=>{if(!t.stationary||this.destroyed)return null;const i=t.state,o=n(i.spatialReference),r=this.hidpi?t.pixelRatio:1,s=this.imageNormalizationSupported&&i.worldScreenWidth&&i.worldScreenWidth<i.size[0];s?(g[0]=i.worldScreenWidth,g[1]=i.size[1]):this.imageRotationSupported?(g[0]=i.size[0],g[1]=i.size[1]):c(g,i);const a=Math.floor(g[0]*r)>this.imageMaxWidth||Math.floor(g[1]*r)>this.imageMaxHeight,p=o&&(i.extent.xmin<o.valid[0]||i.extent.xmax>o.valid[1]),m=!this.imageNormalizationSupported&&p,h=!a&&!m,d=this.imageRotationSupported?i.rotation:0;if(h){const t=s?i.paddedViewState.center:i.center;this._imagePromise=this._singleExport(i,g,t,i.resolution,d,r,e)}else{let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);m&&(t=Math.min(i.worldScreenWidth,t)),this._imagePromise=this._tiledExport(i,t,d,r,e)}return this._imagePromise.then((async t=>{if(this._imagePromise=null,!this.destroyed){this.bitmaps=null!=t?t:[];for(const e of this.container.children)t.includes(e)||e.fadeOut().then((()=>{e.remove()}));for(const e of t)this.container.addChild(e),e.fadeIn()}})).catch((t=>{throw this._imagePromise=null,t}))}),5e3)}destroy(){this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}updateExports(t){for(const e of this.container.children){if(!e.visible||!e.stage)return;t(e),e.invalidateTexture(),e.requestRender()}}async _export(t,e,i,o,r,s){const a=await this.fetchSource(t,Math.floor(e*r),Math.floor(i*r),{rotation:o,pixelRatio:r,signal:s}),n=new m(a,"additive");return n.x=t.xmin,n.y=t.ymax,n.resolution=t.width/e,n.rotation=o,n.pixelRatio=r,n}async _singleExport(t,e,i,o,r,a,n){!function(t,e,i,o){const[r,s]=e,[a,n]=o,p=.5*i;t[0]=r-p*a,t[1]=s-p*n,t[2]=r+p*a,t[3]=s+p*n}(u,i,o,e);const p=new s(u[0],u[1],u[2],u[3],t.spatialReference);return[await this._export(p,e[0],e[1],r,a,n)]}_tiledExport(t,e,i,o,r){const a=p.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),n=new h(a),m=n.getTileCoverage(t);if(!m)return null;const d=[];return m.forEach(((a,p,m,h)=>{f.set(a,p,m,h),n.getTileBounds(u,f);const l=new s(u[0],u[1],u[2],u[3],t.spatialReference);d.push(this._export(l,e,e,i,o,r))})),Promise.all(d)}};t([o()],w.prototype,"_imagePromise",void 0),t([o()],w.prototype,"bitmaps",void 0),t([o()],w.prototype,"container",void 0),t([o()],w.prototype,"fetchSource",void 0),t([o()],w.prototype,"hidpi",void 0),t([o()],w.prototype,"imageMaxWidth",void 0),t([o()],w.prototype,"imageMaxHeight",void 0),t([o()],w.prototype,"imageRotationSupported",void 0),t([o()],w.prototype,"imageNormalizationSupported",void 0),t([o()],w.prototype,"requestUpdate",void 0),t([o()],w.prototype,"updating",null),w=t([r("esri.views.2d.layers.support.ExportStrategy")],w);var _=w;export{_ as E};
