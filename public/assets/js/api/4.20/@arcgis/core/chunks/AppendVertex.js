/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{i as e,b as t}from"../core/lang.js";import{e as s}from"./arrayUtils.js";import{E as r}from"./Evented.js";import i from"../geometry/Polygon.js";import n from"../geometry/Polyline.js";import{c as o,k as a,a as h,e as l,j as c,p,r as u,d}from"./vec2.js";import{a as g,f,d as m}from"./vec2f64.js";import{p as y,w as v,b as x,T as w,j as R,h as V}from"./mathUtils.js";import{c as z,l as P}from"./vec4.js";import{a as Z,f as T,b as M}from"./vec4f64.js";import k from"../geometry/Point.js";import{g as E}from"../geometry/SpatialReference.js";const A=g();class S{constructor(e,t){this.spatialReference=e,this.viewingMode=t,this._unnormalizationInfo=B(e,t)}tag(e){return e}createNew(){return this.tag(g())}fromPoint(e){return this.tag(f(e.x,e.y))}fromArray(e){return this.tag(f(e[0],e[1]))}toArray(e){return[e[0],e[1]]}clone(e){return this.tag(m(e))}copy(e,t){return o(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],t.hasZ=!1,t.hasM=!1,t.spatialReference=this.spatialReference,t}createPoint(e){return new k({x:e[0],y:e[1],z:void 0,m:void 0,spatialReference:this.spatialReference})}createPointFromArray(e){return new k({x:e[0],y:e[1],z:void 0,m:void 0,spatialReference:this.spatialReference})}createDehydratedPoint(e){return{x:e[0],y:e[1],z:void 0,m:void 0,hasZ:!1,hasM:!1,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,s,r){return a(r,e,t,s)}addDelta(e,t,s){e[0]+=t,e[1]+=s}scale(e,t,s,r){const i=h(A,e,t),n=l(A,s,c(s,i));p(e,e,n,r-1)}rotate(e,t,s){u(e,e,t,s)}pointToArray(e){return[e.x,e.y]}getZ(e,t){return t}hasZ(){return!1}getM(e,t){return t}hasM(){return!1}unnormalize(e){I(e,this._unnormalizationInfo)}fromXYZ(e){return this.tag(f(e[0],e[1]))}toXYZ(e,t=0){return y(e[0],e[1],t)}distance(e,t){return d(e,t)}}class j{constructor(e,t,s){this.valueType=e,this.spatialReference=t,this._unnormalizationInfo=B(t,s)}distance(e,t){return 0===this.valueType?v(e,t):d(e,t)}tag(e){return e}createNew(){return this.tag(x())}fromPoint(e){return this.tag(y(e.x,e.y,0===this.valueType?e.z:e.m))}fromArray(e){return this.tag(y(e[0],e[1],e[2]||0))}toArray(e){return[e[0],e[1],e[2]]}clone(e){return this.tag(w(e))}copy(e,t){return R(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],0===this.valueType?(t.z=e[2],t.hasZ=!0,t.hasM=!1):(t.m=e[2],t.hasZ=!1,t.hasM=!0),t.spatialReference=this.spatialReference,t}createPoint(e){return new k({x:e[0],y:e[1],z:0===this.valueType?e[2]:void 0,m:1===this.valueType?e[2]:void 0,spatialReference:this.spatialReference})}createPointFromArray(e){return new k({x:e[0],y:e[1],z:0===this.valueType?e[2]:void 0,m:1===this.valueType?e[2]:void 0,spatialReference:this.spatialReference})}createDehydratedPoint(e){const t=0===this.valueType,s=1===this.valueType;return{x:e[0],y:e[1],z:t?e[2]:void 0,m:s?e[2]:void 0,hasZ:t,hasM:s,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,s,r){return V(r,e,t,s)}addDelta(e,t,s,r){e[0]+=t,e[1]+=s,0===this.valueType&&(e[2]+=r)}scale(e,t,s,r){const i=h(A,e,t),n=l(A,s,c(s,i));p(e,e,n,r-1)}rotate(e,t,s){u(e,e,t,s)}pointToArray(e){return 0===this.valueType?[e.x,e.y,e.z]:[e.x,e.y,e.m]}getZ(e,t){return 0===this.valueType?e[2]:t}hasZ(){return 0===this.valueType}getM(e,t){return 1===this.valueType?e[2]:t}hasM(){return 1===this.valueType}unnormalize(e){I(e,this._unnormalizationInfo)}fromXYZ(e,t=0,s=0){return this.tag(y(e[0],e[1],0===this.valueType?e.length>2?e[2]:t:s))}toXYZ(e,t=0){return this.tag(y(e[0],e[1],0===this.valueType?e[2]:t))}}class X{constructor(e,t){this.spatialReference=e,this._unnormalizationInfo=B(e,t)}distance(e,t){return v(e,t)}tag(e){return e}createNew(){return this.tag(Z())}fromPoint(e){return this.tag(T(e.x,e.y,e.z,e.m))}fromArray(e){return this.tag(T(e[0],e[1],e[2]||0,e[3]||0))}toArray(e){return[e[0],e[1],e[2],e[3]]}clone(e){return this.tag(M(e))}copy(e,t){return z(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.hasZ=!0,t.hasM=!0,t.spatialReference=this.spatialReference,t}createPoint(e){return new k({x:e[0],y:e[1],z:e[2],m:e[3],spatialReference:this.spatialReference})}createPointFromArray(e){return new k({x:e[0],y:e[1],z:e[2],m:e[3],spatialReference:this.spatialReference})}createDehydratedPoint(e){return{x:e[0],y:e[1],z:e[2],m:e[3],hasZ:!0,hasM:!0,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,s,r){return P(r,e,t,s)}addDelta(e,t,s,r){e[0]+=t,e[1]+=s,e[2]+=r}scale(e,t,s,r){const i=h(A,e,t),n=l(A,s,c(s,i));p(e,e,n,r-1)}rotate(e,t,s){u(e,e,t,s)}pointToArray(e){return[e.x,e.y,e.z,e.m]}getZ(e){return e[2]}hasZ(){return!0}getM(e){return e[3]}hasM(){return!0}unnormalize(e){I(e,this._unnormalizationInfo)}fromXYZ(e,t=0,s=0){return this.tag(T(e[0],e[1],e.length>2?e[2]:t,s))}toXYZ(e){return y(e[0],e[1],e[2])}}function H(e,t,s,r){return e&&t?new X(s,r):t?new j(1,s,r):e?new j(0,s,r):new S(s,r)}function I(e,t){if(!t.supported)return;let s=1/0,r=-1/0;const i=t.upperBoundX-t.lowerBoundX;e.forEach((e=>{let n=e.pos[0];for(;n<t.lowerBoundX;)n+=i;for(;n>t.upperBoundX;)n-=i;s=Math.min(s,n),r=Math.max(r,n),e.pos[0]=n}));const n=r-s;i-n<n&&e.forEach((e=>{e.pos[0]<0&&(e.pos[0]+=i)}))}function B(e,t){const s=E(e);return"global"===t&&s?{supported:!0,lowerBoundX:s.valid[0],upperBoundX:s.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}class O{constructor(e){this.left=null,this.right=null,this.type="vertex",this.index=null,this.component=e}get pos(){return this._pos}set pos(e){this._pos=e,this.component.unnormalizeVertexPositions()}}class _{constructor(e,t,s){this.type="edge",this.component=e,this.left=t,this.right=s,t.right=this,s.left=this}}class b{constructor(e){this.vertices=[],this.edges=[],this.data=e}unnormalizeVertexPositions(){this.vertices.length<=1||this.data.coordinateHelper.unnormalize(this.vertices)}updateVertexIndex(e,t){if(0===this.vertices.length)return;const s=this.vertices[0];let r=null,i=e,n=t;do{r=i,r.index=n++,i=r.right?r.right.right:null}while(null!=i&&i!==s);r.left&&r!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(r),this.vertices.length-1)}getFirstVertex(){return 0===this.vertices.length?null:this.vertices[0]}getLastVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].left}swapVertices(e,t){const s=this.vertices[e];this.vertices[e]=this.vertices[t],this.vertices[t]=s}iterateVertices(t){if(0===this.vertices.length)return;const s=this.vertices[0];let r=s;do{t(r,r.index),r=e(r.right)?r.right.right:null}while(r!==s&&null!=r)}}class D extends r{constructor(e){super(),this.coordinateHelper=e,this.undoStack=[],this.redoStack=[],this.components=[]}apply(e,s=1){return 0!==s&&!t(this.lastOperation)&&this.lastOperation.accumulate(e)||(e.apply(),this.undoStack.push(e),this.redoStack=[]),e}undo(){if(this.undoStack.length>0){const e=this.undoStack.pop();return e.undo(),this.redoStack.push(e),e}return null}get canUndo(){return this.undoStack.length>0}get lastOperation(){return this.undoStack.length>0?this.undoStack[this.undoStack.length-1]:null}redo(){if(this.redoStack.length>0){const e=this.redoStack.pop();return e.apply(),this.undoStack.push(e),e}return null}get canRedo(){return this.redoStack.length>0}toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.createPoint(this.components[0].vertices[0].pos)}toPolyline(){const e=[],t=this.coordinateHelper.toArray;return this.components.forEach(((s,r)=>{const i=[];let n=s.vertices.find((e=>null==e.left));const o=n;do{i.push(t(n.pos)),n=n.right?n.right.right:null}while(n&&n!==o);e.push(i)})),new n({paths:e,spatialReference:this.coordinateHelper.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}toPolygon(){const t=[],s=this.coordinateHelper.toArray;return this.components.forEach(((r,i)=>{const n=[],o=r.vertices[0];let a=o;const h=a;do{n.push(s(a.pos)),a=e(a.right)?a.right.right:null}while(a&&a!==h);r.isClosed()&&n.push(s(o.pos)),t.push(n)})),new i({rings:t,spatialReference:this.coordinateHelper.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(e,t){const r=H(e.hasZ,e.hasM,e.spatialReference,t),i=new D(r);switch(e.type){case"polygon":{const t=e.rings;for(let e=0;e<t.length;++e){const n=t[e],o=new b(i),a=n.length>2&&s(n[0],n[n.length-1]),h=a?n.length-1:n.length;for(let e=0;e<h;++e){const t=r.fromArray(n[e]),s=new O(o);o.vertices.push(s),s.pos=t,s.index=e}const l=o.vertices.length-1;for(let e=0;e<l;++e){const t=o.vertices[e],s=o.vertices[e+1],r=new _(o,t,s);o.edges.push(r)}if(a){const e=new _(o,o.vertices[o.vertices.length-1],o.vertices[0]);o.edges.push(e)}i.components.push(o)}}break;case"polyline":for(const t of e.paths){const e=new b(i),s=t.length;for(let i=0;i<s;++i){const s=r.fromArray(t[i]),n=new O(e);e.vertices.push(n),n.pos=s,n.index=i}const n=e.vertices.length-1;for(let t=0;t<n;++t){const s=e.vertices[t],r=e.vertices[t+1],i=new _(e,s,r);e.edges.push(i)}i.components.push(e)}break;case"point":{const t=new b(i),s=new O(t);s.index=0,s.pos=i.coordinateHelper.fromPoint(e),t.vertices.push(s),i.components.push(t)}}return i}}class Y{constructor(e,t,s){this.editGeometry=e,this.component=t,this.pos=s,this.addedVertex=null,this.originalEdge=null,this.left=null,this.right=null}apply(){let s="redo";t(this.addedVertex)&&(s="apply",this.addedVertex=new O(this.component));const r=this.component.getLastVertex();if(t(r))this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,this.addedVertex.index=0;else{let s=null;r.right&&(this.originalEdge=r.right,s=this.originalEdge.right,this.component.edges.splice(this.component.edges.indexOf(this.originalEdge),1)),this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,t(this.left)&&(this.left=new _(this.component,r,this.addedVertex)),this.component.edges.push(this.left),r.right=this.left,e(this.originalEdge)&&e(s)&&(t(this.right)&&(this.right=new _(this.component,this.addedVertex,s)),this.component.edges.push(this.right),s.left=this.right),this.component.updateVertexIndex(this.addedVertex,r.index+1)}const i={addedVertices:[this.addedVertex],operation:s};this.editGeometry.emit("change",i)}undo(){if(t(this.addedVertex))return null;this.component.vertices.splice(this.component.vertices.indexOf(this.addedVertex),1),e(this.left)&&(this.component.edges.splice(this.component.edges.indexOf(this.left),1),this.left.left.right=null),e(this.right)&&(this.component.edges.splice(this.component.edges.indexOf(this.right),1),this.right.right.left=null),e(this.originalEdge)&&(this.component.edges.push(this.originalEdge),this.originalEdge.left.right=this.originalEdge,this.originalEdge.right.left=this.originalEdge),e(this.left)?this.component.updateVertexIndex(this.left.left,this.left.left.index):this.component.updateVertexIndex(this.addedVertex,0);const s={removedVertices:[this.addedVertex],operation:"undo"};this.editGeometry.emit("change",s)}accumulate(){return!1}}export{Y as A,b as C,D as E,O as V,_ as a,H as c};
