/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{i as t,d as e,b as s}from"../core/lang.js";import{d as i,m as r}from"./mat4.js";import{c as o,b as a,I as n}from"./mat4f64.js";import{t as h,h as m,w as c,u as d,j as l,p as g,e as u,b as _}from"./mathUtils.js";import{c as b,a as f}from"./sphere.js";import{b as p}from"./mathUtils2.js";import{C as y,a as v,r as S}from"./utils4.js";import{O as A}from"./ArrayPool.js";import{g as V}from"./uid.js";import{a as j}from"./Util.js";class T{constructor(){this._disposed=!1}get disposed(){return this._disposed}get shaderTransformation(){return this._shaderTransformation}acquire(t,e,s,i,r,o){this.id=V(),this.geometry=t,this.material=e,this.transformation=s,this.instanceParameters=i,this.origin=r,this._shaderTransformation=o,this._disposed=!1}release(){this._disposed=!1}dispose(){this._disposed=!0}getStaticTransformation(){return this.transformation}getShaderTransformation(){return t(this._shaderTransformation)?this._shaderTransformation(this.transformation):this.transformation}computeAttachmentOrigin(t){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,t):this.geometry.computeAttachmentOrigin(t))&&(h(t,t,this.getStaticTransformation()),!0)}}T.pool=new A(T);class R{constructor(t){this.channel=t,this.id=V()}}class x extends y{constructor(t={}){super(),this.type=1,this._geometryRecords=new Array,this._geometries=new Array,this._objectTransformation=o(),this._bvObjectSpace=new L,this._bvWorldSpace=new L,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=null==t.castShadow||t.castShadow,this.metadata=t.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new O),this.transformation=o();const{geometries:e,materials:s,transformations:i,origins:r}=t;if(Array.isArray(e)){j(s.length===e.length,"Object3D: materials don't match geometries"),j(i.length===e.length,"Object3D: transformations don't match geometries"),this._geometryRecords.length=e.length,this._geometries.length=e.length;for(let t=0;t<e.length;t++)this._geometries[t]=e[t],this._geometryRecords[t]=T.pool.acquire(e[t],s[t],a(i[t]),{highlights:null,occludees:null,visible:!0},r&&r[t])}}get geometryRecords(){return this._geometryRecords}get geometries(){return this._geometries}get transformation(){return this._objectTransformation}set transformation(t){i(this._objectTransformation,t),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}dispose(){this._geometryRecords.length=0,this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(t){j(null==this._parentLayer||null==t,"Object3D can only be added to a single Layer"),this._parentLayer=t}getNumGeometryRecords(){return this._geometryRecords.length}getGeometryRecord(t){return j(t>=0&&t<this._geometryRecords.length,"Object3d.getGeometryDataByIndex: index out of range"),this._geometryRecords[t]}addGeometry(e,s,i,r,o,a){i=i||n,this._geometries.push(e);const h=T.pool.acquire(e,s,i,r||{highlights:null,occludees:null,visible:!0},o,a);return this._geometryRecords.push(h),this._hasVolatileTransformation=this._hasVolatileTransformation||t(h.shaderTransformation),this._emit("objectGeometryAdded",{object:this,record:h}),this._invalidateBoundingVolume(),h}removeGeometry(e){const s=this._geometryRecords.splice(e,1)[0];return this._hasVolatileTransformation=t(s.shaderTransformation)?this._geometryRecords.some((e=>t(e.shaderTransformation))):this._hasVolatileTransformation,s.dispose(),this._geometries.splice(e,1),this._emit("objectGeometryRemoved",{object:this,record:s}),this._invalidateBoundingVolume(),s}removeAllGeometries(){for(;this.getNumGeometryRecords()>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(t){this._emit("vertexAttrsUpdated",{object:this,record:this._geometryRecords[t]}),this._invalidateBoundingVolume()}get isVisible(){return this._visible}setVisible(t){this._visible=t;for(const t of this._geometryRecords)t.instanceParameters.visible=this._visible;this._emit("visibilityChanged",this)}maskOccludee(){const t=new R(1);for(const e of this._geometryRecords)e.instanceParameters.occludees=v(e.instanceParameters.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const e of this._geometryRecords)e.instanceParameters.occludees=S(e.instanceParameters.occludees,t);this._emit("occlusionChanged",this)}highlight(){const t=new R(0);for(const e of this._geometryRecords)e.instanceParameters.highlights=v(e.instanceParameters.highlights,t);return this._emit("highlightChanged",this),t}removeHighlight(t){for(const e of this._geometryRecords)e.instanceParameters.highlights=S(e.instanceParameters.highlights,t);this._emit("highlightChanged",this)}getCombinedStaticTransformation(t,s){return r(e(s,o()),this.transformation,t.getStaticTransformation())}getCombinedShaderTransformation(t,e){return e=e||o(),r(e,this.transformation,t.getShaderTransformation()),e}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._validateBoundingVolume(),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._validateBoundingVolume(),this._bvObjectSpace}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(let e=0;e<this._geometryRecords.length;++e){const s=this._geometries[e],i=this._geometryRecords[e],r=s.boundingInfo;t(r)&&(this._calculateTransformedBoundingVolume(r,this._bvObjectSpace,i.getShaderTransformation()),this._calculateTransformedBoundingVolume(r,this._bvWorldSpace,this.getCombinedShaderTransformation(i)))}m(this._bvObjectSpace.bounds,this._bvObjectSpace.min,this._bvObjectSpace.max,.5),m(this._bvWorldSpace.bounds,this._bvWorldSpace.min,this._bvWorldSpace.max,.5);const e=_(),i=_(),r=p(this.transformation);for(let t=0;t<this._geometryRecords.length;++t){const o=this._geometries[t].boundingInfo;if(s(o))continue;const a=this._geometryRecords[t].getShaderTransformation(),n=p(a);h(e,o.getCenter(),a);const m=c(e,this._bvObjectSpace.bounds),d=o.getBSRadius()*n;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],m+d),h(i,e,this.transformation);const l=c(i,this._bvWorldSpace.bounds),g=d*r;this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],l+g)}this._bvDirty=!1}_calculateTransformedBoundingVolume(t,e,s){const i=t.getBBMin(),r=t.getBBMax(),o=d(i),a=d(r);h(o,o,s),h(a,a,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],o[t],a[t]),e.max[t]=Math.max(e.max[t],o[t],a[t]);for(let t=0;t<3;++t){l(o,i),l(a,r),o[t]=r[t],a[t]=i[t],h(o,o,s),h(a,a,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],o[t],a[t]),e.max[t]=Math.max(e.max[t],o[t],a[t])}}_invalidateBoundingVolume(){this._bvDirty=!0,t(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(e,s){t(this._parentLayer)&&this._parentLayer.events.emit(e,s)}get test(){const t=this;return{hasGeometry:e=>t._geometries.indexOf(e)>-1,getGeometryIndex:e=>t._geometries.indexOf(e)}}}class O{constructor(){this.min=g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class L extends O{constructor(){super(...arguments),this.bounds=b()}init(){u(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),u(this.max,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),f(this.bounds)}}export{T as G,x as O,R as a};
