/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{s as e,a as t,n,f as r,g as s,d as o,e as i,j as a,t as l,b as c,I as u,T as h,O as d,p as f,h as p}from"./mathUtils.js";import{f as m,c as g,a as y}from"./vec3f32.js";import{c as b,r as v,k as _}from"./plane.js";import{w as x}from"./ray.js";import{a0 as w,g as A,af as j,S as M,T as z,V as P,O,m as S,C as T,z as C,B as E,n as F,y as D,p as U,a as q,b as G,P as N,D as R,c as I,E as B,X as L,a1 as k,a3 as H,F as V,G as W,H as Z,I as $,ag as Q,K as J,a5 as K,R as X,a8 as Y,ah as ee,ai as te,a6 as ne,a9 as re}from"./VertexColor.glsl.js";import{g as se}from"./geometryDataUtils.js";import{a as oe,c as ie}from"./Util.js";import{clone as ae,b as le,v as ce,w as ue,x as he,i as de,j as fe}from"../core/lang.js";import{r as pe,a as me,j as ge}from"./mat4.js";import{c as ye}from"./mat4f64.js";import{f as be}from"./vec2f64.js";import{s as ve}from"./vec4.js";import{d as _e,O as xe}from"./vec4f64.js";import{projectPoint as we}from"../geometry/projection.js";import{i as Ae,z as je}from"./aaBoundingBox.js";import{a as Me}from"./aaBoundingRect.js";import{b as ze,a as Pe,r as Oe}from"../geometry/Polygon.js";import{m as Se}from"./dehydratedFeatures.js";import Te from"../Graphic.js";import{fromJSON as Ce}from"../geometry/support/jsonUtils.js";import{E as Ee}from"./Evented.js";import Fe from"../core/Handles.js";import{P as De}from"../core/scheduling.js";import{C as Ue}from"./utils4.js";import{O as qe}from"./ArrayPool.js";import{d as Ge}from"./frustum.js";import{c as Ne,l as Re,m as Ie,g as Be}from"./sphere.js";import{n as Le}from"./InterleavedLayout.js";import{_ as ke}from"./tslib.es6.js";import{m as He,e as Ve,c as We,d as Ze}from"./VertexArrayObject.js";var $e;!function(e){e.length=function(e,t){const n=e[t],r=e[t+1],s=e[t+2];return Math.sqrt(n*n+r*r+s*s)},e.normalize=function(e,t){const n=e[t],r=e[t+1],s=e[t+2],o=1/Math.sqrt(n*n+r*r+s*s);e[t]*=o,e[t+1]*=o,e[t+2]*=o},e.scale=function(e,t,n){e[t]*=n,e[t+1]*=n,e[t+2]*=n},e.add=function(e,t,n,r,s,o=t){(s=s||e)[o]=e[t]+n[r],s[o+1]=e[t+1]+n[r+1],s[o+2]=e[t+2]+n[r+2]},e.subtract=function(e,t,n,r,s,o=t){(s=s||e)[o]=e[t]-n[r],s[o+1]=e[t+1]-n[r+1],s[o+2]=e[t+2]-n[r+2]}}($e||($e={}));const Qe=$e;var Je,Ke,Xe,Ye;!function(e){const t=.5,n=[[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t],[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t]],r=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],s=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),i=new Uint16Array(36);for(let e=0;e<6;e++)for(let t=0;t<6;t++)i[6*e+t]=e;const a=new Uint16Array(36);for(let e=0;e<6;e++)a[6*e+0]=0,a[6*e+1]=1,a[6*e+2]=2,a[6*e+3]=2,a[6*e+4]=3,a[6*e+5]=0;e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(24);for(let r=0;r<8;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new w([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}],["uv0",{size:2,data:s}]],[["position",o],["normal",i],["uv0",a]])}}(Je||(Je={})),function(e){const t=.5,n=[[-t,0,-t],[t,0,-t],[t,0,t],[-t,0,t],[0,-t,0],[0,t,0]],r=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],s=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(18);for(let r=0;r<6;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new w([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}]],[["position",s],["normal",o]])}}(Ke||(Ke={})),function(r){const s=.5,o=m(-s,0,-s),i=m(s,0,-s),a=m(0,0,s),l=m(0,.5,0),c=g(),u=g(),h=g(),d=g(),f=g();e(c,o,l),e(u,o,i),t(h,c,u),n(h,h),e(c,i,l),e(u,i,a),t(d,c,u),n(d,d),e(c,a,l),e(u,a,o),t(f,c,u),n(f,f);const p=[o,i,a,l],y=[0,-1,0,h[0],h[1],h[2],d[0],d[1],d[2],f[0],f[1],f[2]],b=[0,1,2,3,1,0,3,2,1,3,0,2],v=[0,0,0,1,1,1,2,2,2,3,3,3];r.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(12);for(let n=0;n<4;n++)t[3*n]=p[n][0]*e[0],t[3*n+1]=p[n][1]*e[1],t[3*n+2]=p[n][2]*e[2];return new w([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:y}]],[["position",new Uint16Array(b)],["normal",new Uint16Array(v)]])}}(Xe||(Xe={})),function(u){u.createBoxGeometry=Je.createGeometry,u.createDiamondGeometry=Ke.createGeometry,u.createTetrahedronGeometry=Xe.createGeometry,u.createSphereGeometry=function(e,t,n,r={uv:!0}){const s=-Math.PI,o=2*Math.PI,i=-Math.PI/2,a=Math.PI,l=Math.max(3,Math.floor(t)),c=Math.max(2,Math.floor(n)),u=(l+1)*(c+1),h=new Float32Array(3*u),d=new Float32Array(3*u),f=new Float32Array(2*u),p=[];let m=0;for(let t=0;t<=c;t++){const n=[],r=t/c,u=i+r*a,g=Math.cos(u);for(let t=0;t<=l;t++){const i=t/l,a=s+i*o,c=Math.cos(a)*g,p=Math.sin(u),y=-Math.sin(a)*g;h[3*m]=c*e,h[3*m+1]=p*e,h[3*m+2]=y*e,d[3*m]=c,d[3*m+1]=p,d[3*m+2]=y,f[2*m]=i,f[2*m+1]=r,n.push(m),++m}p.push(n)}const g=new Uint32Array(2*l*(c-1)*3);m=0;for(let e=0;e<c;e++)for(let t=0;t<l;t++){const n=p[e][t],r=p[e][t+1],s=p[e+1][t+1],o=p[e+1][t];0===e?(g[m++]=n,g[m++]=s,g[m++]=o):e===c-1?(g[m++]=n,g[m++]=r,g[m++]=s):(g[m++]=n,g[m++]=r,g[m++]=s,g[m++]=s,g[m++]=o,g[m++]=n)}const y=[["position",g],["normal",g]],b=[["position",{size:3,data:h,exclusive:!0}],["normal",{size:3,data:d,exclusive:!0}]];return r.uv&&(b.push(["uv0",{size:2,data:f,exclusive:!0}]),y.push(["uv0",g])),r.offset&&(y[0][0]="offset",b[0][0]="offset",y.push(["position",new Uint32Array(g.length)]),b.push(["position",{size:3,data:Float64Array.from(r.offset),exclusive:!0}])),new w(b,y)},u.createPolySphereGeometry=function(e,t,n){const r=e;let s,o;if(n)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const e=r*(1+Math.sqrt(5))/2;s=[-r,e,0,r,e,0,-r,-e,0,r,-e,0,0,-r,e,0,r,e,0,-r,-e,0,r,-e,e,0,-r,e,0,r,-e,0,-r,-e,0,r],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let t=0;t<s.length;t+=3)Qe.scale(s,t,e/Qe.length(s,t));let i={};function a(t,n){t>n&&([t,n]=[n,t]);const r=t.toString()+"."+n.toString();if(i[r])return i[r];let o=s.length;return s.length+=3,Qe.add(s,3*t,s,3*n,s,o),Qe.scale(s,o,e/Qe.length(s,o)),o/=3,i[r]=o,o}for(let e=0;e<t;e++){const e=o.length,t=new Uint32Array(4*e);for(let n=0;n<e;n+=3){const e=o[n],r=o[n+1],s=o[n+2],i=a(e,r),l=a(r,s),c=a(s,e),u=4*n;t[u]=e,t[u+1]=i,t[u+2]=c,t[u+3]=r,t[u+4]=l,t[u+5]=i,t[u+6]=s,t[u+7]=c,t[u+8]=l,t[u+9]=i,t[u+10]=l,t[u+11]=c}o=t,i={}}const l=new Float32Array(s);for(let e=0;e<l.length;e+=3)Qe.normalize(l,e);const c=[["position",o],["normal",o]],u=[["position",{size:3,data:new Float32Array(s),exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}]];return new w(u,c)},u.createPointGeometry=function(e,t,n,r,s,o,i){const a=t?[t[0],t[1],t[2]]:[0,0,0],l=e?[e[0],e[1],e[2]]:[0,0,1];o=o||[0,0];const c=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],u=null!=r&&2===r.length?r:[1,1],h=[["position",{size:3,data:a,exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}],["uv0",{size:o.length,data:o}],["color",{size:4,data:c,exclusive:!0}],["size",{size:2,data:u}]];if(null!=s){const e=new Float32Array([s[0],s[1],s[2],s[3]]);h.push(["auxpos1",{size:4,data:e}])}if(null!=i){const e=new Float32Array([i[0],i[1],i[2],i[3]]);h.push(["auxpos2",{size:4,data:e}])}return new w(h,null,1)},u.updatePointGeometry=function(e,t,n,r,s,o,i,a){if(null!=e){const{data:t}=a.getMutableAttribute("normal");t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=t){const{data:e}=a.getMutableAttribute("position");e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=n){const{data:e}=a.getMutableAttribute("color");e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3]}if(null!=r){const{data:e}=a.getMutableAttribute("size");e[0]=r[0],e[1]=r[1]}if(null!=s){const{data:e}=a.getMutableAttribute("auxpos1");e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3]}if(null!=o){const{data:e}=a.getMutableAttribute("uv0");e[0]=o[0],e[1]=o[1]}if(null!=i){const{data:e}=a.getMutableAttribute("auxpos2");e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3]}},u.createPointArrayGeometry=function(e,t){const n=new Float32Array(3*e.length),r=new Float32Array(t?3*e.length:3),s=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let i=0;i<e.length;i++)n[3*i]=e[i][0],n[3*i+1]=e[i][1],n[3*i+2]=e[i][2],t&&(r[3*i]=t[i][0],r[3*i+1]=t[i][1],r[3*i+2]=t[i][2]),s[i]=i,o[i]=0;return t||(r[0]=0,r[1]=1,r[2]=0),new w([["position",{size:3,data:n,exclusive:!0}],["normal",{size:3,data:r,exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",s],["normal",t?s:o],["uv0",o]],1)},u.createTriangleGeometry=function(){const e=new Uint16Array([0,1,2]),t=new Uint16Array([0,0,0]),n=new Uint16Array([0,0,0]);return new w([["position",{size:3,data:[0,0,0,0,0,100,100,0,0],exclusive:!0}],["normal",{size:3,data:[0,1,0],exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",e],["normal",t],["uv0",n]])};const h=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function d(e,r,s,i,a){return!(Math.abs(o(r,e))>a)&&(t(s,e,r),n(s,s),t(i,s,e),n(i,i),!0)}function f(e,t,n,r,s,o,i){return d(e,t,s,o,i)||d(e,n,s,o,i)||d(e,r,s,o,i)}u.createSquareGeometry=function(e=h){const t=new Array(12);for(let n=0;n<4;n++)for(let r=0;r<3;r++)t[3*n+r]=e[n][r];const n=new Uint32Array([0,1,2,2,3,0]),r=new Uint32Array([0,0,0,0,0,0]);return new w([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:[0,0,1],exclusive:!0}],["uv0",{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],["color",{size:4,data:[255,255,255,255],exclusive:!0}]],[["position",n],["normal",r],["uv0",n],["color",r]])},u.createConeGeometry=function(e,t,n,r,s=!0,o=!0){let i=0;const a=t,l=e;let c=m(0,i,0),u=m(0,i+l,0),h=m(0,-1,0),d=m(0,1,0);r&&(i=l,u=m(0,0,0),c=m(0,i,0),h=m(0,1,0),d=m(0,-1,0));const f=[u,c],p=[h,d],g=n+2,y=Math.sqrt(l*l+a*a);if(r)for(let e=n-1;e>=0;e--){const t=e*(2*Math.PI/n),r=m(Math.cos(t)*a,i,Math.sin(t)*a);f.push(r);const s=m(l*Math.cos(t)/y,-a/y,l*Math.sin(t)/y);p.push(s)}else for(let e=0;e<n;e++){const t=e*(2*Math.PI/n),r=m(Math.cos(t)*a,i,Math.sin(t)*a);f.push(r);const s=m(l*Math.cos(t)/y,a/y,l*Math.sin(t)/y);p.push(s)}const b=new Uint32Array(2*(n+2)*3),v=new Uint32Array(2*(n+2)*3);let _=0,x=0;if(s){for(let e=3;e<f.length;e++)b[_++]=1,b[_++]=e-1,b[_++]=e,v[x++]=0,v[x++]=0,v[x++]=0;b[_++]=f.length-1,b[_++]=2,b[_++]=1,v[x++]=0,v[x++]=0,v[x++]=0}if(o){for(let e=3;e<f.length;e++)b[_++]=e,b[_++]=e-1,b[_++]=0,v[x++]=e,v[x++]=e-1,v[x++]=1;b[_++]=0,b[_++]=2,b[_++]=f.length-1,v[x++]=1,v[x++]=2,v[x++]=p.length-1}const A=new Float32Array(3*g);for(let e=0;e<g;e++)A[3*e]=f[e][0],A[3*e+1]=f[e][1],A[3*e+2]=f[e][2];const j=new Float32Array(3*g);for(let e=0;e<g;e++)j[3*e]=p[e][0],j[3*e+1]=p[e][1],j[3*e+2]=p[e][2];return new w([["position",{size:3,data:A,exclusive:!0}],["normal",{size:3,data:j,exclusive:!0}]],[["position",b],["normal",v]])},u.createCylinderGeometry=function(e,a,l,c,u,h){const d=c?y(c):m(1,0,0),f=u?y(u):m(0,0,0);h=null==h||h;const p=g();n(p,d);const b=g();r(b,p,Math.abs(e));const v=g();r(v,b,-.5),s(v,v,f);const _=m(0,1,0);Math.abs(1-o(p,_))<.2&&i(_,0,0,1);const x=g();t(x,p,_),n(x,x),t(_,x,p);const A=2*l+(h?2:0),j=l+(h?2:0),M=new Float32Array(3*A),z=new Float32Array(3*j),P=new Float32Array(2*A),O=new Uint32Array(3*l*(h?4:2)),S=new Uint32Array(3*l*(h?4:2));h&&(M[3*(A-2)+0]=v[0],M[3*(A-2)+1]=v[1],M[3*(A-2)+2]=v[2],P[2*(A-2)]=0,P[2*(A-2)+1]=0,M[3*(A-1)+0]=M[3*(A-2)+0]+b[0],M[3*(A-1)+1]=M[3*(A-2)+1]+b[1],M[3*(A-1)+2]=M[3*(A-2)+2]+b[2],P[2*(A-1)]=1,P[2*(A-1)+1]=1,z[3*(j-2)+0]=-p[0],z[3*(j-2)+1]=-p[1],z[3*(j-2)+2]=-p[2],z[3*(j-1)+0]=p[0],z[3*(j-1)+1]=p[1],z[3*(j-1)+2]=p[2]);const T=function(e,t,n){O[e]=t,S[e]=n};let C=0;const E=g(),F=g();for(let e=0;e<l;e++){const t=e*(2*Math.PI/l);r(E,_,Math.sin(t)),r(F,x,Math.cos(t)),s(E,E,F),z[3*e+0]=E[0],z[3*e+1]=E[1],z[3*e+2]=E[2],r(E,E,a),s(E,E,v),M[3*e+0]=E[0],M[3*e+1]=E[1],M[3*e+2]=E[2],P[2*e+0]=e/l,P[2*e+1]=0,M[3*(e+l)+0]=M[3*e+0]+b[0],M[3*(e+l)+1]=M[3*e+1]+b[1],M[3*(e+l)+2]=M[3*e+2]+b[2],P[2*(e+l)+0]=e/l,P[2*e+1]=1;const n=(e+1)%l;T(C++,e,e),T(C++,e+l,e),T(C++,n,n),T(C++,n,n),T(C++,e+l,e),T(C++,n+l,n)}if(h){for(let e=0;e<l;e++){const t=(e+1)%l;T(C++,A-2,j-2),T(C++,e,j-2),T(C++,t,j-2)}for(let e=0;e<l;e++){const t=(e+1)%l;T(C++,e+l,j-1),T(C++,A-1,j-1),T(C++,t+l,j-1)}}return new w([["position",{size:3,data:M,exclusive:!0}],["normal",{size:3,data:z,exclusive:!0}],["uv0",{size:2,data:P,exclusive:!0}]],[["position",O],["normal",S],["uv0",O]])},u.createTubeGeometry=function(e,t,n,r,s){n=n||10,r=null==r||r,oe(e.length>1);const o=[],i=[];for(let e=0;e<n;e++){o.push([0,-e-1,-(e+1)%n-1]);const r=e/n*2*Math.PI;i.push([Math.cos(r)*t,Math.sin(r)*t])}return u.createPathExtrusionGeometry(i,e,[[0,0,0]],o,r,s)},u.createPathExtrusionGeometry=function(o,l,u,h,d,p=m(0,0,0)){const y=o.length,A=new Float32Array(l.length*y*3+(6*u.length||0)),j=new Float32Array(l.length*y*3+(u?6:0)),M=(l.length-1)*y*6+3*h.length*2,z=new Uint32Array(M),P=new Uint32Array(M);let O=0,S=0,T=0,C=0;const E=g(),F=g(),D=g(),U=g(),q=g(),G=g(),N=g(),R=c(),I=g(),B=g(),L=g(),k=g(),H=g(),V=b();i(I,0,1,0),e(F,l[1],l[0]),n(F,F),d?(s(R,l[0],p),n(D,R)):i(D,0,0,1),f(F,D,I,I,q,D,et),a(U,D),a(k,q);for(let e=0;e<u.length;e++)r(G,q,u[e][0]),r(R,D,u[e][2]),s(G,G,R),s(G,G,l[0]),A[O++]=G[0],A[O++]=G[1],A[O++]=G[2];j[S++]=-F[0],j[S++]=-F[1],j[S++]=-F[2];for(let e=0;e<h.length;e++)z[T++]=h[e][0]>0?h[e][0]:-h[e][0]-1+u.length,z[T++]=h[e][1]>0?h[e][1]:-h[e][1]-1+u.length,z[T++]=h[e][2]>0?h[e][2]:-h[e][2]-1+u.length,P[C++]=0,P[C++]=0,P[C++]=0;let W=u.length;const Z=u.length-1;for(let i=0;i<l.length;i++){let c=!1;if(i>0){a(E,F),i<l.length-1?(e(F,l[i+1],l[i]),n(F,F)):c=!0,s(B,E,F),n(B,B),s(L,l[i-1],U),v(l[i],B,V);_(V,x(L,E),R)?(e(R,R,l[i]),n(D,R),t(q,B,D),n(q,q)):f(B,U,k,I,q,D,et),a(U,D),a(k,q)}d&&(s(R,l[i],p),n(H,R));for(let e=0;e<y;e++)if(r(G,q,o[e][0]),r(R,D,o[e][1]),s(G,G,R),n(N,G),j[S++]=N[0],j[S++]=N[1],j[S++]=N[2],s(G,G,l[i]),A[O++]=G[0],A[O++]=G[1],A[O++]=G[2],!c){const t=(e+1)%y;z[T++]=W+e,z[T++]=W+y+e,z[T++]=W+t,z[T++]=W+t,z[T++]=W+y+e,z[T++]=W+y+t;for(let e=0;e<6;e++)P[C++]=z[T-6+e]-Z}W+=y}const $=l[l.length-1];for(let e=0;e<u.length;e++)r(G,q,u[e][0]),r(R,D,u[e][1]),s(G,G,R),s(G,G,$),A[O++]=G[0],A[O++]=G[1],A[O++]=G[2];const Q=S/3;j[S++]=F[0],j[S++]=F[1],j[S++]=F[2];const J=W-y;for(let e=0;e<h.length;e++)z[T++]=h[e][0]>=0?W+h[e][0]:-h[e][0]-1+J,z[T++]=h[e][2]>=0?W+h[e][2]:-h[e][2]-1+J,z[T++]=h[e][1]>=0?W+h[e][1]:-h[e][1]-1+J,P[C++]=Q,P[C++]=Q,P[C++]=Q;return new w([["position",{size:3,data:A,exclusive:!0}],["normal",{size:3,data:j,exclusive:!0}]],[["position",z],["normal",P]])},u.createPolylineGeometry=function(e,t,n){oe(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),oe(3===e[0].length,"createPolylineGeometry(): malformed vertex"),oe(null==t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),oe(null==t||3===t[0].length,"createPolylineGeometry(): malformed normal");const r=new Float64Array(3*e.length),s=new Uint32Array(2*(e.length-1));let o=0,i=0;for(let t=0;t<e.length;t++){for(let n=0;n<3;n++)r[o++]=e[t][n];t>0&&(s[i++]=t-1,s[i++]=t)}const a=[],l=[];if(a.push(["position",s]),l.push(["position",{size:3,data:r,exclusive:!0}]),t){const n=new Float32Array(3*t.length);let r=0;for(let s=0;s<e.length;s++)for(let e=0;e<3;e++)n[r++]=t[s][e];a.push(["normal",s]),l.push(["normal",{size:3,data:n,exclusive:!0}])}return n&&(l.push(["color",{size:4,data:n}]),a.push(["color",se(n.length/4)])),new w(l,a,2)},u.createExtrudedTriangle=function(e,t,n,r,s=0){const o=new Array(18),i=[[-t,s,r/2],[n,s,r/2],[0,e+s,r/2],[-t,s,-r/2],[n,s,-r/2],[0,e+s,-r/2]],a=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let e=0;e<6;e++)o[3*e]=i[e][0],o[3*e+1]=i[e][1],o[3*e+2]=i[e][2];return new w([["position",{size:3,data:o,exclusive:!0}]],[["position",a]])},u.transformInPlace=function(e,t){const n=e.getMutableAttribute("position").data;for(let e=0;e<n.length;e+=3){const r=n[e],s=n[e+1],o=n[e+2];i(tt,r,s,o),l(tt,tt,t),n[e]=tt[0],n[e+1]=tt[1],n[e+2]=tt[2]}},u.cgToGIS=function(e,t=e){const n=e.vertexAttributes,r=n.get("position").data,s=n.get("normal").data;if(s){const e=t.getMutableAttribute("normal").data;for(let t=0;t<s.length;t+=3){const n=s[t+1];e[t+1]=-s[t+2],e[t+2]=n}}if(r){const e=t.getMutableAttribute("position").data;for(let t=0;t<r.length;t+=3){const n=r[t+1];e[t+1]=-r[t+2],e[t+2]=n}}return t},u.makeOrthoBasisDirUp=d,u.makeOrthoBasisDirUpFallback=f}(Ye||(Ye={}));const et=.99619469809,tt=g();var nt=Ye;function rt(e){return"declaredClass"in e}function st(e){return"declaredClass"in e}function ot(e,t){if(!e)return null;if(function(e){return"declaredClass"in e}(e))return e;const n=new Te({layer:t,sourceLayer:t});return n.visible=e.visible,n.symbol=ae(e.symbol),n.attributes=ae(e.attributes),n.geometry=it(e.geometry),n}function it(e){return le(e)?null:rt(e)?e:Ce(function(e){const t=e.spatialReference.toJSON();switch(e.type){case"point":{const{x:n,y:r,z:s,m:o}=e;return{x:n,y:r,z:s,m:o,spatialReference:t}}case"polygon":{const{rings:n,hasZ:r,hasM:s}=e;return{rings:at(n),hasZ:r,hasM:s,spatialReference:t}}case"polyline":{const{paths:n,hasZ:r,hasM:s}=e;return{paths:at(n),hasZ:r,hasM:s,spatialReference:t}}case"extent":{const{xmin:n,xmax:r,ymin:s,ymax:o,zmin:i,zmax:a,mmin:l,mmax:c,hasZ:u,hasM:h}=e;return{xmin:n,xmax:r,ymin:s,ymax:o,zmin:i,zmax:a,mmin:l,mmax:c,hasZ:u,hasM:h,spatialReference:t}}case"multipoint":{const{points:n,hasZ:r,hasM:s}=e;return{points:ct(n)?lt(n):n,hasZ:r,hasM:s,spatialReference:t}}default:return}}(e))}function at(e){return function(e){for(const t of e)if(0!==t.length)return ct(t);return!1}(e)?e.map((e=>lt(e))):e}function lt(e){return e.map((e=>he(e)))}function ct(e){return e.length&&(ce(e[0])||ue(e[0]))}function ut(e,t){if(!e)return null;let n;if(st(e)){if(null==t)return e.clone();if(st(t))return t.copy(e)}return null!=t?(n=t,n.x=e.x,n.y=e.y,n.spatialReference=e.spatialReference,e.hasZ?(n.z=e.z,n.hasZ=e.hasZ):(n.z=null,n.hasZ=!1),e.hasM?(n.m=e.m,n.hasM=!0):(n.m=null,n.hasM=!1)):(n=Se(e.x,e.y,e.z,e.spatialReference),e.hasM&&(n.m=e.m,n.hasM=!0)),n}function ht(e,t){if("point"===e.type)return ft(e,t,!1);if(rt(e))switch(e.type){case"extent":return ft(e.center,t,!1);case"polygon":return ft(e.centroid,t,!1);case"polyline":return ft(dt(e),t,!0);case"mesh":return ft(e.origin,t,!1)}else switch(e.type){case"extent":return ft(function(e){const t=u(e.zmin);return Se(.5*(e.xmax+e.xmin),.5*(e.ymax+e.ymin),t?.5*(e.zmax+e.zmin):void 0,e.spatialReference)}(e),t,!0);case"polygon":return ft(function(e){const t=e.rings[0];if(!t||0===t.length)return null;const n=Oe(e.rings,e.hasZ);return Se(n[0],n[1],n[2],e.spatialReference)}(e),t,!0);case"polyline":return ft(dt(e),t,!0)}}function dt(e){const t=e.paths[0];if(!t||0===t.length)return null;const n=ze(t,Pe(t)/2);return Se(n[0],n[1],n[2],e.spatialReference)}function ft(e,t,n){const r=n?e:ut(e);return t&&e?we(e,r,t)?r:null:r}function pt(e,t,n,r=0){if(e){t||(t=Me());const s=e;let o=.5*s.width*(n-1),i=.5*s.height*(n-1);return s.width<1e-7*s.height?o+=i/20:s.height<1e-7*s.width&&(i+=o/20),ve(t,s.xmin-o-r,s.ymin-i-r,s.xmax+o+r,s.ymax+i+r),t}return null}function mt(e,t){for(let n=0;n<e.geometries.length;++n){const r=e.geometries[n].getMutableAttribute("auxpos1");r&&r.data[3]!==t&&(r.data[3]=t,e.geometryVertexAttrsUpdated(n))}}function gt(e,t){const n=_e(xe);return de(e)&&(n[0]=e[0],n[1]=e[1],n[2]=e[2]),de(t)?n[3]=t:de(e)&&e.length>3&&(n[3]=e[3]),n}function yt(e,t,n,r,s,o=[0,0,0,0]){for(let t=0;t<3;++t)de(e)&&null!=e[t]?o[t]=e[t]:de(n)&&null!=n[t]?o[t]=n[t]:o[t]=s[t];return de(t)?o[3]=t:de(r)?o[3]=r:o[3]=s[3],o}function bt(e=d,t,n,r=1){const s=new Array(3);if(le(t)||le(n))s[0]=1,s[1]=1,s[2]=1;else{let r,o=0;for(let i=2;i>=0;i--){const a=e[i];let l;const c=null!=a,u=0===i&&!r&&!c,h=n[i];"symbol-value"===a||u?l=0!==h?t[i]/h:1:c&&"proportional"!==a&&isFinite(a)&&(l=0!==h?a/h:1),null!=l&&(s[i]=l,r=l,o=Math.max(o,Math.abs(l)))}for(let e=2;e>=0;e--)null==s[e]?s[e]=r:0===s[e]&&(s[e]=.001*o)}for(let e=2;e>=0;e--)s[e]/=r;return h(s)}function vt(e){return null!=e.isPrimitive&&(e=[e.width,e.depth,e.height]),_t(e)?null:"Symbol sizes may not be negative values"}function _t(e){if(Array.isArray(e)){for(const t of e)if(!_t(t))return!1;return!0}return null==e||e>=0}function xt(e,t,n,r=ye()){const s=e||0,o=t||0,i=n||0;return 0!==s&&pe(r,r,-s/180*Math.PI),0!==o&&me(r,r,o/180*Math.PI),0!==i&&ge(r,r,i/180*Math.PI),r}function wt(e,t){return null!=t.minDemResolution?t.minDemResolution:Ae(e)?t.minDemResolutionForPoints:.01*je(e)}const At={"bottom-left":be(0,0),bottom:be(.5,0),"bottom-right":be(1,0),left:be(0,.5),center:be(.5,.5),right:be(1,.5),"top-left":be(0,1),top:be(.5,1),"top-right":be(1,1)},jt=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","vertexAttrsUpdated"];class Mt{constructor(e,t){this._objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new zt,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth))}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),zt.clearPool(),qt[0]=null,Bt.prune(),Zt.prune()}add(e,t=e.length){this._objectCount+=t,this._grow(e,t);const n=zt.acquire();for(let r=0;r<t;r++){const t=e[r];this._isDegenerate(t)?this._degenerateObjects.add(t):(n.init(this._root),this._add(t,n))}zt.release(n)}remove(e,t=null){this._objectCount-=e.length;const n=zt.acquire();for(const r of e){const e=de(t)?t:Re(this._objectToBoundingSphere(r),Lt);Et(e[3])?(n.init(this._root),this._remove(r,e,n)):this._degenerateObjects.delete(r)}zt.release(n),this._shrink()}update(e,t){if(!Et(t[3])&&this._isDegenerate(e))return;const n=function(e){return qt[0]=e,qt}(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const r=x(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNode(r,e))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObject(r,e)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObject(r,e)&&n(e)})),!0}))}forEachAlongRayWithVerticalOffset(e,t,n,r){const s=x(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNodeWithOffset(s,e,r))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObjectWithOffset(s,e,r)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObjectWithOffset(s,e,r)&&n(e)})),!0}))}forEach(e){this._forEachNode(this._root,(t=>{const n=t.node;return n.terminals.forAll(e),null!==n.residents&&n.residents.forAll(e),!0})),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,n,o=(()=>!0),i=1/0){let a=1/0,l=1/0,c=null;const u=Tt(e,t),h=r=>{if(--i,!o(r))return;const s=this._objectToBoundingSphere(r);if(!Ge(n,s))return;const u=Ct(e,t,Be(s)),h=u-s[3],d=u+s[3];h<a&&(a=h,l=d,c=r)};return this._forEachNodeDepthOrdered(this._root,(o=>{if(i<=0||!Ge(n,o.bounds))return!1;r(Nt,u,o.halfSize),s(Nt,Nt,o.bounds);if(Ct(e,t,Nt)>l)return!1;const a=o.node;return a.terminals.forAll((e=>h(e))),null!==a.residents&&a.residents.forAll((e=>h(e))),!0}),e,t),c}forEachInDepthRange(e,t,n,o,i,a,l){let c=-1/0,u=1/0;const h={setRange:e=>{1===n?(c=Math.max(c,e.near),u=Math.min(u,e.far)):(c=Math.max(c,-e.far),u=Math.min(u,-e.near))}};h.setRange(o);const d=Ct(t,n,e),f=Tt(t,n),p=Tt(t,-1*n),m=e=>{if(!l(e))return;const r=this._objectToBoundingSphere(e),s=Be(r),o=Ct(t,n,s)-d,f=o-r[3],p=o+r[3];f>u||p<c||!Ge(a,r)||i(e,h)};this._forEachNodeDepthOrdered(this._root,(e=>{if(!Ge(a,e.bounds))return!1;r(Nt,f,e.halfSize),s(Nt,Nt,e.bounds);if(Ct(t,n,Nt)-d>u)return!1;r(Nt,p,e.halfSize),s(Nt,Nt,e.bounds);if(Ct(t,n,Nt)-d<c)return!1;const o=e.node;return o.terminals.forAll((e=>m(e))),null!==o.residents&&o.residents.forAll((e=>m(e))),!0}),t,n)}forEachNode(e){this._forEachNode(this._root,(t=>e(t.node,t.bounds,t.halfSize)))}_intersectsNode(e,t){return Ot(t.bounds,2*-t.halfSize,Rt),Ot(t.bounds,2*t.halfSize,It),ie(e.origin,e.direction,Rt,It)}_intersectsNodeWithOffset(e,t,n){return Ot(t.bounds,2*-t.halfSize,Rt),Ot(t.bounds,2*t.halfSize,It),n.applyToMinMax(Rt,It),ie(e.origin,e.direction,Rt,It)}_intersectsObject(e,t){const n=this._objectToBoundingSphere(t);return!(n[3]>0)||Ie(n,e)}_intersectsObjectWithOffset(e,t,n){const r=this._objectToBoundingSphere(t);return!(r[3]>0)||Ie(n.applyToBoundingSphere(r),e)}_forEachNode(e,t){let n=zt.acquire().init(e);const r=[n];for(;0!==r.length;){if(n=r.pop(),t(n)&&!n.isLeaf())for(let e=0;e<n.node.children.length;e++){n.node.children[e]&&r.push(zt.acquire().init(n).advance(e))}zt.release(n)}}_forEachNodeDepthOrdered(e,t,n,r=1){let s=zt.acquire().init(e);const o=[s];for(!function(e,t,n){if(!Zt.length)for(let e=0;e<8;++e)Zt.push({index:0,distance:0});for(let n=0;n<8;++n){const r=Ft[n];Zt.data[n].index=n,Zt.data[n].distance=Ct(e,t,r)}Zt.sort(((e,t)=>e.distance-t.distance));for(let e=0;e<8;++e)n[e]=Zt.data[e].index}(n,r,$t);0!==o.length;){if(s=o.pop(),t(s)&&!s.isLeaf())for(let e=7;e>=0;--e){const t=$t[e];s.node.children[t]&&o.push(zt.acquire().init(s).advance(t))}zt.release(s)}}_remove(e,t,n){Bt.clear();const r=n.advanceTo(t,((e,t)=>{Bt.push(e.node),Bt.push(t)}))?n.node.terminals:n.node.residents;if(r.removeUnordered(e),0===r.length)for(let e=Bt.length-2;e>=0;e-=2){const t=Bt.data[e],n=Bt.data[e+1];if(!this._purge(t,n))break}}_nodeIsEmpty(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0}_purge(e,t){return t>=0&&(e.children[t]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new De({shrink:!0})),!0)}_add(e,t){t.advanceTo(this._objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const r=zt.acquire().init(e);this._add(t.getItemAt(n),r),zt.release(r)}}_grow(e,t){if(0!==t&&(St(e,t,(e=>this._objectToBoundingSphere(e)),kt),Et(kt[3])&&!this._fitsInsideTree(kt)))if(this._nodeIsEmpty(this._root.node))Re(kt,this._root.bounds),this._root.halfSize=1.25*kt[3];else{const e=this._rootBoundsForRootAsSubNode(kt);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(kt,e):this._growRootAsSubNode(e),zt.release(e)}}_rebuildTree(e,t){a(Ht,t.bounds),Ht[3]=t.halfSize,St([e,Ht],2,(e=>e),Vt);const n=zt.acquire().init(this._root);this._root.initFrom(null,Vt,1.25*Vt[3]),this._forEachNode(n,(e=>(this.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&this.add(e.node.residents.data,e.node.residents.length),!0))),zt.release(n)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,(e=>(n=Math.max(n,e.depth),n+t<=this._maximumDepth))),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let r=-1/0;const s=this._root.bounds,o=this._root.halfSize;for(let e=0;e<3;e++){const i=s[e]-o-(n[e]-t),a=n[e]+t-(s[e]+o),l=Math.max(0,Math.ceil(i/(2*o))),c=Math.max(0,Math.ceil(a/(2*o)))+1,u=2**Math.ceil(Math.log(l+c)*Math.LOG2E);r=Math.max(r,u),Wt[e].min=l,Wt[e].max=c}for(let e=0;e<3;e++){let t=Wt[e].min,n=Wt[e].max;const i=(r-(t+n))/2;t+=Math.ceil(i),n+=Math.floor(i);const a=s[e]-o-t*o*2;Gt[e]=a+(n+t)*o}return Gt[3]=r*o*Ut,zt.acquire().initFrom(null,Gt,r*o,0)}_growRootAsSubNode(e){const t=this._root.node;a(kt,this._root.bounds),kt[3]=this._root.halfSize,this._root.init(e),e.advanceTo(kt,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,r=0;for(;r<t.length&&null==e;)n=r++,e=t[n];for(;r<t.length;)if(t[r++])return-1;return n}_isDegenerate(e){return!Et(this._objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}}class zt{constructor(){this.bounds=Ne(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(e,t,n,r=this.depth){return this.node=de(e)?e:zt.createEmptyNode(),de(t)&&Re(t,this.bounds),this.halfSize=n,this.depth=r,this}advance(e){let t=this.node.children[e];t||(t=zt.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=Ft[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.bounds[3]=this.halfSize*Ut,this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const r=this._childIndex(e);t&&t(this,r),this.advance(r)}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new De({shrink:!0}),residents:new De({shrink:!0})}}static acquire(){return zt._pool.acquire()}static release(e){zt._pool.release(e)}static clearPool(){zt._pool.prune()}}function Pt(e,t){e[0]=Math.max(e[0],t[0]+t[3]),e[1]=Math.max(e[1],t[1]+t[3]),e[2]=Math.max(e[2],t[2]+t[3])}function Ot(e,t,n){n[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t}function St(e,t,n,r){if(1===t){const t=n(e[0]);Re(t,r)}else{Rt[0]=1/0,Rt[1]=1/0,Rt[2]=1/0,It[0]=-1/0,It[1]=-1/0,It[2]=-1/0;for(let r=0;r<t;r++){const t=n(e[r]);Et(t[3])&&(o=t,(s=Rt)[0]=Math.min(s[0],o[0]-o[3]),s[1]=Math.min(s[1],o[1]-o[3]),s[2]=Math.min(s[2],o[2]-o[3]),Pt(It,t))}p(r,Rt,It,.5),r[3]=Math.max(It[0]-Rt[0],It[1]-Rt[1],It[2]-Rt[2])/2}var s,o}function Tt(e,t){let n=1/0,r=null;for(let s=0;s<8;++s){const o=Ct(e,t,Dt[s]);o<n&&(n=o,r=Dt[s])}return r}function Ct(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}function Et(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}zt._pool=new qe(zt);const Ft=[f(-1,-1,-1),f(1,-1,-1),f(-1,1,-1),f(1,1,-1),f(-1,-1,1),f(1,-1,1),f(-1,1,1),f(1,1,1)],Dt=[f(-1,-1,-1),f(-1,-1,1),f(-1,1,-1),f(-1,1,1),f(1,-1,-1),f(1,-1,1),f(1,1,-1),f(1,1,1)],Ut=Math.sqrt(3),qt=[null];const Gt=Ne(),Nt=c(),Rt=c(),It=c(),Bt=new De,Lt=Ne(),kt=Ne(),Ht=Ne(),Vt=Ne(),Wt=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],Zt=new De,$t=[0,0,0,0,0,0,0,0];class Qt extends Ue{constructor(e,t=""){var n,r,s;super(),this.apiLayerUid=t,this.type=0,this.events=new Ee,this.isSliceable=!1,this._objects=new De,this._stageHandles=new Fe,this.apiLayerUid=t,this.isVisible=null==(n=null==e?void 0:e.isVisible)||n,this.isPickable=null==(r=null==e?void 0:e.isPickable)||r,this.updatePolicy=null!=(s=null==e?void 0:e.updatePolicy)?s:0}get objects(){return this._objects}destroy(){this.detachStage(),this._stage=null}attachStage(e){this.detachStage(),this._stage=e;for(const t of jt)this._stageHandles.add(this.events.on(t,(n=>e.handleEvent(t,n))))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),de(this._octree)&&this._octree.add([e])}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),de(this._octree)&&this._octree.remove([e]))}addMany(e){this._objects.pushArray(e);for(const t of e)t.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),de(this._octree)&&this._octree.add(e)}removeMany(e){const t=new Array;if(this._objects.removeUnorderedMany(e,e.length,t),0!==t.length){for(const e of t)e.parentLayer=null;this.events.emit("layerObjectsRemoved",{layer:this,objects:t}),de(this._octree)&&this._octree.remove(t)}}sync(){de(this._stage)&&1!==this.updatePolicy&&this._stage.syncLayer(this.id)}notifyObjectBBChanged(e,t){de(this._octree)&&this._octree.update(e,t)}getSpatialQueryAccelerator(){return le(this._octree)&&this._objects.length>50&&this._createOctree(),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=fe(this._octree)}_createOctree(){this._octree=new Mt((e=>e.boundingVolumeWorldSpace.bounds)),this._octree.add(this._objects.data,this._objects.length)}}function Jt(e){return de(e)&&0===e.type}function Kt(e){e.attributes.add("position","vec2"),e.varyings.add("uv","vec2"),e.vertex.code.add(A`
    void main(void) {
      gl_Position = vec4(position, 0.0, 1.0);
      uv = position * 0.5 + vec2(0.5);
    }
  `)}const Xt=Le().vec3f("position"),Yt=Le().vec3f("position").vec2f("uv0"),en=Le().vec3f("position").vec4u8("color");class tn{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,n,r){j(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,r)}}var nn=Object.freeze({__proto__:null,build:function(e){const t=new M,n=1===e.output;return t.include(z,{linearDepth:n}),t.include(P,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),e.multipassTerrainEnabled&&t.varyings.add("depth","float"),n&&(t.include(O,e),t.vertex.uniforms.add("cameraNearFar","vec2"),t.varyings.add("linearDepth","float")),t.vertex.code.add(A`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      ${e.multipassTerrainEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${n?A`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);`:A`transformPosition(proj, view, vpos);`}
    }
  `),t.include(S,e),t.fragment.include(T),e.multipassTerrainEnabled&&(t.fragment.include(C),t.include(E,e)),t.fragment.uniforms.add("eColor","vec4"),4===e.output&&t.include(F),t.fragment.code.add(A`
  void main() {
    discardBySlice(vpos);
    ${e.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 color = ${e.attributeColor?"vColor * eColor;":"eColor;"}

    if (color.a < ${A.float(D)}) {
      discard;
    }

    ${7===e.output?A`gl_FragColor = vec4(color.a);`:""}

    ${0===e.output?A`gl_FragColor = highlightSlice(color, vpos); ${e.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${4===e.output?A`outputHighlight();`:""};
    ${1===e.output?A`outputDepth(linearDepth);`:""};
  }
  `),t}});class rn extends G{initializeProgram(e){const t=rn.shader.get(),n=this.configuration,r=t.build({output:n.output,OITEnabled:0===n.transparencyPassType,attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,multipassTerrainEnabled:n.multipassTerrainEnabled,cullAboveGround:n.cullAboveGround});return new N(e.rctx,r,R)}bindPass(e,t){I(this.program,t.camera.projectionMatrix),this.program.setUniform4fv("eColor",e.color),4===this.configuration.output&&B(this.program,t),(1===this.configuration.output||t.multipassTerrainEnabled)&&this.program.setUniform2fv("cameraNearFar",t.camera.nearFar),t.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",t.inverseViewport),L(this.program,t))}bindDraw(e){k(this.program,e),this.program.rebindTextures(),H(this.program,this.configuration,e)}setPipelineState(e,t){const n=this.configuration,r=3===e,s=2===e;return He({blending:0!==n.output&&7!==n.output||!n.transparent?null:r?V:W(e),culling:Ve(n.cullFace),depthTest:{func:Z(e)},depthWrite:r||s?n.writeDepth&&We:null,colorWrite:Ze,stencilWrite:n.sceneHasOcludees?$:null,stencilTest:n.sceneHasOcludees?t?Q:J:null,polygonOffset:r||s?n.polygonOffset&&sn:K(n.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this.setPipelineState(this.configuration.transparencyPassType,!0),this.setPipelineState(this.configuration.transparencyPassType,!1)}getPipelineState(e){return e?this._occludeePipelineState:this.pipeline}}rn.shader=new X(nn,(()=>Promise.resolve().then((function(){return nn}))));const sn={factor:1,units:1};class on extends q{constructor(){super(...arguments),this.output=0,this.cullFace=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.sceneHasOcludees=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}ke([U({count:8})],on.prototype,"output",void 0),ke([U({count:3})],on.prototype,"cullFace",void 0),ke([U()],on.prototype,"slicePlaneEnabled",void 0),ke([U()],on.prototype,"vertexColors",void 0),ke([U()],on.prototype,"transparent",void 0),ke([U()],on.prototype,"polygonOffset",void 0),ke([U()],on.prototype,"enableOffset",void 0),ke([U()],on.prototype,"writeDepth",void 0),ke([U()],on.prototype,"sceneHasOcludees",void 0),ke([U({count:4})],on.prototype,"transparencyPassType",void 0),ke([U()],on.prototype,"multipassTerrainEnabled",void 0),ke([U()],on.prototype,"cullAboveGround",void 0);class an extends Y{constructor(e){super(e,cn),this.supportsEdges=!0,this.techniqueConfig=new on}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.cullFace=this.params.cullFace,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.enableOffset=!t||t.camera.relativeElevation<ee,this.techniqueConfig.multipassTerrainEnabled=!!t&&t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!t&&t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,n,r,s,o,i){te(e,t,r,s,o,void 0,i)}getGLMaterial(e){return 0===e.output||7===e.output||4===e.output||1===e.output&&this.params.writeLinearDepth?new ln(e):void 0}createBufferWriter(){return new tn(en)}}class ln extends ne{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(rn,this._material.getTechniqueConfig(this._output,e),this._technique)}beginSlot(e){if(4===this._output)return 3===e;return e===(this._technique.configuration.transparent?this._technique.configuration.writeDepth?5:8:3)}_updateOccludeeState(e){e.hasOccludees!==this._material.params.sceneHasOcludees&&this._material.setParameterValues({sceneHasOcludees:e.hasOccludees})}ensureParameters(e){0!==this._output&&7!==this._output||this._updateOccludeeState(e),this.updateParameters(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}getPipelineState(e,t){return this._technique.getPipelineState(t)}}const cn={color:[1,1,1,1],transparent:!1,writeDepth:!0,writeLinearDepth:!1,vertexColors:!1,polygonOffset:!1,slicePlaneEnabled:!1,cullFace:0,sceneHasOcludees:!1,...re};export{an as C,tn as D,nt as G,Mt as O,Yt as P,Kt as S,Qt as W,bt as a,xt as b,ht as c,wt as d,_t as e,it as f,en as g,ot as h,Jt as i,Xt as j,ut as k,pt as l,gt as m,At as n,yt as o,mt as u,vt as v};
