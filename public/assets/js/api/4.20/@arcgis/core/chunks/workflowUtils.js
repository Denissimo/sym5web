/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../Graphic.js";import{i as t,r as a,b as i}from"../core/lang.js";import{whenOrAbort as r,eachAlways as n}from"../core/promiseUtils.js";import{p as s}from"./screenUtils.js";import{whenFalseOnce as o,init as l}from"../core/watchUtils.js";import{d as c}from"./diffUtils.js";import{c as u,a as p}from"./drapedUtils.js";import{m as y}from"./lengthUtils.js";import{a as f}from"./sizeVariableUtils.js";import{getVisualVariableValues as d}from"./visualVariableUtils.js";import{t as m}from"./symbolConversion.js";import{getDisplayedSymbol as h}from"../symbols/support/symbolUtils.js";import{G as g}from"./GraphicState.js";import{h as b}from"./hitTestSelectUtils.js";function w(e){const t=e.sourceLayer,a=function(e){switch(e.type){case"class-breaks":case"simple":case"unique-value":case"dot-density":case"dictionary":return!0;default:return!1}}(t.renderer)&&d(t.renderer,e),i=a?a.map((e=>e.variable)):[],r=i.filter((e=>"rotation"===e.type&&(!e.axis||"heading"===e.axis))),n=r[0],s=1===r.length&&n.field&&!n.valueExpression,o=i.filter((e=>"size"===e.type)),l=o[0],c=1===o.length&&"real-world-size"===f(l)&&l.field&&!l.useSymbolValue&&!l.valueExpression;return{rotation:s?v(n,t):null,size:c?I(l,t):null}}function v(e,t){const a="heading"===(e.axis||"heading")&&"arithmetic"===e.rotationType?-1:1,i=e.field,r=t.fields&&t.fields.filter((e=>e.name===i)),n=r&&1===r.length?r[0].type:"double",s={initial:0,current:0};return{field:i,getDefault:()=>Promise.resolve(0),getValue:e=>(s.current=s.initial-a*e,S((s.current+360)%360,n)),initValue:e=>{s.initial=null!=e?e:s.current,s.current=0},isUpdatingInteractively:!1}}function I(e,t){const a=e.field,r=e.axis,n=t.fields&&t.fields.filter((e=>e.name===a)),s=n&&1===n.length?n[0].type:"double",o={updating:!1,initial:0,current:0},l=y[e.valueUnit];let c;return c="area"===e.valueRepresentation?e=>(e*l/2)**2*Math.PI:"radius"===e.valueRepresentation||"distance"===e.valueRepresentation?e=>e*l/2:e=>e*l,{field:a,getDefault:async(e,t)=>S(c(await async function(e,t,a){if(i(t))return 0;const{symbol:r}=m(t);if(i(r)||"web-style"===r.type)return 0;const n=r.symbolLayers.getItemAt(0);if(!n)return 0;switch(n.type){case"icon":{const{computeIconLayerResourceSize:e}=await import("./symbolLayerUtils.js");return n.size||Math.min(G.icon,(await e(n,G.icon))[0])||G.icon}case"text":return n.size||G.text;case"line":return n.size||G.line;case"object":{const{computeObjectLayerResourceSize:t}=await import("./symbolLayerUtils.js");return function(e,t){switch(t){case"width":return e[0];case"depth":return e[1];case"height":return e[2];default:return e[2]||e[1]||e[0]}}(await t(n,e.scale/G.viewScaleSizeFactor),a)}case"path":case"extrude":return n.size||e.scale/G.viewScaleSizeFactor;case"fill":case"water":default:return 0}}(t,e,r)),s),getValue:(e,t)=>(o.initial||(o.initial=t.pixelSizeAt(t.center)),o.current=o.initial*e,S(o.current,s)),initValue:e=>{o.initial=null!=e?e:o.current,o.current=0},isUpdatingInteractively:!1}}function S(e,t){switch(t){case"small-integer":case"integer":case"long":return Math.round(e);case"double":case"single":return e;default:return 0}}async function j(e){const a=await h(e,{useSourceLayer:!0,ignoreGraphicSymbol:!0}),i=c(e.symbol,a);t(i)&&(e.symbol=a)}async function U(e,t,a){await V(e,t);const i=e.on("create",(async i=>{if("cancel"===i.state)return V(e,t);if("complete"===i.state){const e=i.graphic;e.sourceLayer||(e.sourceLayer=t.layer),e.attributes||(e.attributes={...t.template.prototype.attributes}),await j(e),a(e)}}));return{remove:()=>{i.remove(),e.cancel()}}}async function V(t,a){const r=a.layer,n={...a.template.prototype.attributes};await async function(t,a,r){var n;if("3d"!==t.view.type)return;const s=new e({sourceLayer:a,attributes:r}),{rotation:o,size:l}=w(s);let c=await h(s,{useSourceLayer:!0}),u=!1;for(const e of[l,o]){if(i(e))continue;null==r[e.field]&&(r[e.field]=await e.getDefault(c,t.view),u=!0)}u&&(c=await h(s,{useSourceLayer:!0}));switch(null==(n=c)?void 0:n.type){case"simple-fill":case"polygon-3d":t.polygonSymbol=c;break;case"simple-line":case"line-3d":t.polylineSymbol=c;break;case"simple-marker":case"point-3d":t.pointSymbol=c}}(t,r,n);const s={graphicProperties:{attributes:n,sourceLayer:r},hasZ:r.capabilities.data.supportsZ};t.layer.elevationInfo=r.elevationInfo,t.create(function(e){if("mesh"===e||"multipatch"===e)throw new Error("Mesh and Multipatch not supported");return e}(r.geometryType),s)}function z(e,t){return e&&e.find((e=>e.layer===t))}async function L(e,t,a,i){if(0===e.length)return[];const{updatable:s,graphicsByLayer:o}=await a.async((async()=>{const{results:n}=await r(b(t,a),i),s=new Map;n.forEach((({graphic:e})=>(({layer:e})=>{const t=s.get(e);if(!t){const t=new Array;return s.set(e,t),t}return t})(e).push(e)));const o=e.filter((({supports:e,layer:t})=>e.indexOf("update")>-1&&s.has(t)));return 0!==o.length&&a.stopPropagation(),{updatable:o,graphicsByLayer:s}}));return r(n(s.map((async({layer:e})=>{const{objectIdField:t,displayField:a}=e,r=[t];e.fieldsIndex.has(a)&&r.push(a);const n=o.get(e);if(!!n.some((e=>r.some((t=>!(t in e.attributes)))))){const t=e.createQuery();return t.outFields=r,t.returnGeometry=!1,t.objectIds=n.map((e=>e.getObjectId())),e.queryFeatures(t,{signal:i}).then((({features:e})=>e))}return n}))),i)}async function x(e,t,a,i){switch(t.type){case"3d":return L(e,t,a,i);case"2d":return async function(e,t,a,i){if(0===e.length)return[];const s=await a.async((async()=>{const{results:n}=await r(t.hitTest(a),i);if(0===n.length)return[];const s=new Set;n.forEach((({graphic:e})=>s.add(e.layer)));const o=e.items.filter((({layer:e,supports:t})=>t.indexOf("update")>-1&&s.has(e)));return o.length>0&&a.stopPropagation(),o}));return r(n(s.map((({layer:e})=>{const{objectIdField:r,displayField:n}=e,s=[r];e.fieldsIndex.has(n)&&s.push(n);const o=e.createQuery();o.outFields=s,o.returnGeometry=!1;const l="renderer"in e?u({renderer:e.renderer,event:a}):0;return o.geometry=p(a.mapPoint,l,t),o.outSpatialReference=t.spatialReference,e.queryFeatures(o,{signal:i}).then((({features:e})=>e))}))),i)}(e,t,a,i)}}async function F(e,t,a){const i=e.layer,r=i.createQuery();return r.objectIds=[e.getAttribute(i.objectIdField)],r.outFields=["*"],r.outSpatialReference=t.spatialReference,r.returnM=i.capabilities.data.supportsM,r.returnZ=i.capabilities.data.supportsZ,(await i.queryFeatures(r,{signal:a})).features[0]}async function M(e,a,r,n){let s=!1;const{rotation:o,size:l}=n;[o,l].forEach((async r=>{if(i(r))return;const n=a.attributes[r.field];if(t(n))r.initValue(n);else{const t=await r.getDefault(a.symbol,e.view);r.initValue(t),a.setAttribute(r.field,t),s=!0}})),s&&"3d"===e.view.type&&await j(a);const c={multipleSelectionEnabled:!1};return"point"===r.geometryType&&(c.enableRotation=t(o),c.enableScaling=t(l)),e.layer.elevationInfo=r.elevationInfo,e.update(a,c)}async function R(e,a,i,r){var n;if(!t(a.geometry)||"point"!==(null==(n=a.geometry)?void 0:n.type))return;const s=r.rotation,o=!(l=i.toolEventInfo)||"rotate-start"!==l.type&&"rotate"!==l.type&&"rotate-stop"!==l.type?null:l;var l;if(t(s)&&t(o))if("rotate-stop"===o.type)s.isUpdatingInteractively=!1,s.initValue();else{s.isUpdatingInteractively=!0;const{field:t,getValue:i}=s;a.attributes[t]=i(o.angle,e)}const c=r.size,u=function(e){return!e||"scale-start"!==e.type&&"scale"!==e.type&&"scale-stop"!==e.type?null:e}(i.toolEventInfo);if(t(c)&&t(u))if("scale-stop"===u.type)c.isUpdatingInteractively=!1,c.initValue();else{c.isUpdatingInteractively=!0;const{field:t,getValue:i}=c;a.attributes[t]=i(u.xScale,e)}"3d"===e.type&&await j(a)}async function E(e,r,n,s,c){const u=e.clone();await j(u),n.layer.add(u);const p=e.sourceLayer,y=s.whenLayerView(p),f=()=>{const t=e.layer,a=e.attributes[t.objectIdField];return y.then((e=>e.setVisibility(a,!1)),(()=>{})),{remove(){y.then((e=>e.setVisibility(a,!0)),(()=>{}))}}};let d=null,m=null;if("3d"===s.type){const e=new g({graphic:u});d=s.trackGraphicState(e),l(e,"displaying",(e=>{m=e?f():a(m)}))}else m=f();M(n,u,p,r);let h=null;y.then((e=>h=e),(()=>{}));const b=r.size,w=r.rotation,v=e.watch("attributes",(async e=>{let a=!1;for(const r in e){const n=e[r];n!==u.attributes[r]&&(u.setAttribute(r,n),t(b)&&!b.isUpdatingInteractively&&b.field===r&&b.initValue(n),t(w)&&!w.isUpdatingInteractively&&w.field===r&&w.initValue(n),(i(h)||h.requiredFields.includes(r))&&(a=!0))}a&&"3d"===s.type&&await j(u)})),I=n.on("update",(async e=>{const t=e.graphics[0];if("complete"===e.state)return M(n,t,p,r);await R(s,t,e,r),c(t.clone())})),S=n.on(["undo","redo"],(async e=>{c(e.graphics[0].clone())}));s.map.add(n.layer);const U=()=>{};return{interactive:{remove(){S.remove(),I.remove(),n.cancel(),v&&v.remove(),this.remove=U}},visual:{remove(){a(m),s.whenLayerView(p).then((e=>o(e,"updating"))).then((()=>{a(d),n.layer.remove(u),this.remove=U}))}}}}const G={icon:s(24),text:s(12),line:s(1),viewScaleSizeFactor:100};function T(e,t,a){let i=!1;return e.filter((e=>!!i||(i=e===t,i))).map((e=>a[e]()))}function A(e,a){if(e.viewModel.refreshCreationTemplates(),"awaiting-feature-creation-info"===a[0].id){const i=function(e){if(1!==e.length)return null;const t=e[0];if("items"in t){const e=t;return 1===e.items.length?e.items[0]:null}return t}(e.viewModel.featureTemplatesViewModel.items);t(i)&&(e.creationInfo={layer:i.layer,template:i.template},a.shift())}return a}export{M as a,A as b,T as c,U as d,x as e,z as f,w as g,F as h,E as i,V as s,j as u,R as v};
