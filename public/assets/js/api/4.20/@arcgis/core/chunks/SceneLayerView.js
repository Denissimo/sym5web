/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{clone as e,i as t,b as r,d as s}from"../core/lang.js";import{a as n}from"./attributeUtils.js";import{fixFields as o,unpackFieldNames as i,collectLabelingFields as a,collectFilterFields as l}from"../layers/support/fieldUtils.js";import{_ as u}from"./tslib.es6.js";import c,{S as d}from"../core/Accessor.js";import{L as p}from"./Logger.js";import{subclass as f,r as y}from"../core/accessorSupport/decorators/subclass.js";import{HandleOwner as m}from"../core/HandleOwner.js";import{property as h}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import b from"../views/layers/LayerView.js";const w={setAttribute(){},rollback(){},commit(){}};function g(t,s){const n=s.attributes[t.objectIdField],o=t.sessions.get(n);if(o)return o;const i=e(s.attributes),a=new Set;if(null==n)return w;const l=t.attributeOverrides.createInteractiveEditSession(n),u=new Map;let c=0;const d={setAttribute(e,o){if(0!==c)return;const i=t.fieldsIndex.get(e);if(r(i))return;const d=t.attributeStorageInfo.findIndex((e=>e.name===i.name));if(d<0)return;l.set(d,o);const p=t.attributeStorageInfo[d];let f=!1;a.add(e),t.forEachNode(((e,r)=>{const i=((e,t)=>{const r=u.get(e);if(null==r){const r=t.indexOf(n);return u.set(e,r),r}return r})(e,r);if(-1===i)return;const a=t.getAttributeData(e.index);if(a){const r=a[p.name];r&&(r[i]=o,t.setAttributeData(e.index,a,s),f=!0)}})),f&&t.clearMemCache()},rollback(){if(0===c){for(const e of a)this.setAttribute(e,i[e]);l.rollback(),c=1,t.sessions.delete(n)}},commit(){0===c&&(l.commit(),c=2,t.sessions.delete(n))}};return t.sessions.set(n,d),d}function F(e,r){const s=function(e,t){const r=t.edits.updateFeatures;if(!r||0===r.length)return new A;const s=function(e){const t=new Set;if(!e.updatedFeatures)return t;for(const r of e.updatedFeatures)null!=r.objectId&&null==r.error&&t.add(r.objectId);return t}(t),o=new A,i=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)i.set(e.attributeStorageInfo[t].name,t);const a=e.fieldsIndex,l=e.objectIdField,u=r.filter((e=>{const t=n(a,e.attributes,l);return s.has(t)}));return e.forEachNode(((t,r)=>{const s=new Set(r);for(const i of u){const u=n(a,i.attributes,l);if(!s.has(u))continue;const c=r.indexOf(u);for(const r in i.attributes){const s=e.fieldsIndex.normalizeFieldName(r),n=x(o,t.index,s),a=i.attributes[r];n.push({featureIndex:c,featureId:u,value:a})}}})),o}(e,r);if(0===s.size)return;const o=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)o.set(e.attributeStorageInfo[t].name,t);let i=!1;s.forEach(((r,s)=>{const n=e.getAttributeData(s);let a=!1;r.forEach(((r,s)=>{const l=t(n)?n[s]:null,u=o.get(s);for(const{featureIndex:t,value:s,featureId:n}of r)l&&(l[t]=s,a=!0,i=!0),e.attributeOverrides.updateValue(n,u,s)})),a&&e.setAttributeData(s,n,null)})),i&&e.clearMemCache()}function x(e,t,r){const s=function(e,t){const r=e.get(t);if(r)return r;const s=new S;return e.set(t,s),s}(e,t),n=s.get(r);if(n)return n;const o=new Array;return s.set(r,o),o}const S=Map,A=Map;function v(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:t},requiredFields:r}=this;return e.outFields?o(t,[...i(t,e.outFields),...r]):o(t,r)}}}}const I=e=>{let t=class extends e{constructor(){super(...arguments),this.asyncUpdateState=new Map}autoUpdateAsync(e,t){return function(e,t){const r=()=>{o&&!i&&e(s)},s=()=>{if(!o||i)return t();o.clear(),i=!0;const e=y(o,t);return i=!1,e},n=()=>{o&&(o.destroy(),o=null)};let o=new d(r),i=!1;return e(s),{remove:n}}((t=>this.updateAsync(e,t)),t)}async updateAsync(e,t){if(!this.startAsyncUpdate(e)){try{const r=await t();this._set(e,r)}catch(t){p.getLogger(this.declaredClass).warn(`Async update of "${e}" failed. Async update functions should not throw exceptions.`)}this.endAsyncUpdate(e)&&this.updateAsync(e,t)}}startAsyncUpdate(e){var t;const r=null!=(t=this.asyncUpdateState.get(e))?t:0;return 1&r?(this.asyncUpdateState.set(e,2|r),!0):(this.asyncUpdateState.set(e,1|r),!1)}endAsyncUpdate(e){var t;const r=-2&(null!=(t=this.asyncUpdateState.get(e))?t:0);return 2&r?(this.asyncUpdateState.set(e,-3&r),!0):(this.asyncUpdateState.set(e,r),!1)}};return t=u([f("esri.core.AsyncUpdate")],t),t};let U=class extends(I(c)){};U=u([f("esri.core.AsyncUpdate")],U);const j=p.getLogger("esri.views.3d.layers.support.SceneLayerViewRequiredFields");let E=class extends(I(m)){constructor(e){super(e)}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:t},rendererFields:r,labelingFields:n,viewFilterFields:i}=this;return o(e,[...s(t,[]),...s(r,[]),...s(n,[]),...s(i,[])])}initialize(){const e=this.layerView.layer;this.layer=e,this.handles.add([this.autoUpdateAsync("rendererFields",(()=>{const{fieldsIndex:e,renderer:t}=this.layer;return t?N((r=>t.collectRequiredFields(r,e))):null})),this.autoUpdateAsync("labelingFields",(()=>{const{layer:e}=this;return e.labelsVisible?N((t=>a(t,e))):null})),this.autoUpdateAsync("viewFilterFields",(()=>{const{layer:e,filter:t}=this.layerView;return N((r=>l(r,e,t)))}))])}};async function N(e){const t=new Set;try{return await e(t),Array.from(t).sort()}catch(e){return j.error(e),null}}u([h()],E.prototype,"layerView",void 0),u([h()],E.prototype,"layer",void 0),u([h()],E.prototype,"requiredFields",null),u([h()],E.prototype,"rendererFields",void 0),u([h()],E.prototype,"labelingFields",void 0),u([h()],E.prototype,"viewFilterFields",void 0),E=u([f("esri.views.3d.layers.support.SceneLayerViewRequiredFields")],E);class O extends b{constructor(){super(...arguments),this.layer=null,this.filter=null}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}highlight(e){throw new Error("Not implemented")}queryFeatures(e,t){throw new Error("Not implemented")}queryObjectIds(e,t){throw new Error("Not implemented")}queryFeatureCount(e,t){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,t){throw new Error("Not implemented")}}u([h()],O.prototype,"layer",void 0),u([h()],O.prototype,"availableFields",null),u([h()],O.prototype,"maximumNumberOfFeatures",null),u([h({readOnly:!0})],O.prototype,"maximumNumberOfFeaturesExceeded",null),u([h()],O.prototype,"filter",void 0);export{O as S,E as a,g as c,v as d,F as p};
