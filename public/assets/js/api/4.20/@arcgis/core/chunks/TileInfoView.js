/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{g as t}from"../geometry/SpatialReference.js";import{T as o}from"./TileKey.js";import{O as e}from"./ArrayPool.js";function l(t,o){return[t,o]}function s(t,o,e){return t[0]=o,t[1]=e,t}const r=new o("0/0/0/0");class i{constructor(t,o,e,l,s,r,i,n,a,h,c,u){this.level=t,this.resolution=o,this.scale=e,this.origin=l,this.first=s,this.last=r,this.size=i,this.norm=n,this.worldStart=a,this.worldEnd=h,this.worldSize=c,this.wrap=u}static create(o,e,r){const n=t(o.spatialReference),a=l(o.origin.x,o.origin.y),h=l(o.size[0]*e.resolution,o.size[1]*e.resolution),c=l(-1/0,-1/0),u=l(1/0,1/0),f=l(1/0,1/0);let m,g,d,w;return r&&(s(c,Math.max(0,Math.floor((r.xmin-a[0])/h[0])),Math.max(0,Math.floor((a[1]-r.ymax)/h[1]))),s(u,Math.max(0,Math.floor((r.xmax-a[0])/h[0])),Math.max(0,Math.floor((a[1]-r.ymin)/h[1]))),s(f,u[0]-c[0]+1,u[1]-c[1]+1)),o.isWrappable?(m=l(Math.ceil(Math.round((n.valid[1]-n.valid[0])/e.resolution)/o.size[0]),f[1]),g=l(Math.floor((n.origin[0]-a[0])/h[0]),c[1]),d=l(m[0]+g[0]-1,u[1]),w=!0):(g=c,d=u,m=f,w=!1),new i(e.level,e.resolution,e.scale,a,c,u,f,h,g,d,m,w)}normalizeCol(t){if(!this.wrap)return t;const o=this.worldSize[0];return t<0?o-1-Math.abs((t+1)%o):t%o}denormalizeCol(t,o){return this.wrap?this.worldSize[0]*o+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,o,e=!1){r.set(o);const l=e?r.col:this.denormalizeCol(r.col,r.world),s=r.row;return function(t,o,e,l,s){t[0]=o,t[1]=e,t[2]=l,t[3]=s}(t,this.getXForColumn(l),this.getYForRow(s+1),this.getXForColumn(l+1),this.getYForRow(s)),t}getTileCoords(t,o,e=!1){r.set(o);const l=e?r.col:this.denormalizeCol(r.col,r.world);return Array.isArray(t)?s(t,this.getXForColumn(l),this.getYForRow(r.row)):(t.x=this.getXForColumn(l),t.y=this.getYForRow(r.row)),t}}class n{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,o){const{spans:e,lodInfo:l}=this,{level:s}=l;if(0!==e.length)for(const{row:r,colFrom:i,colTo:n}of e)for(let e=i;e<=n;e++)t.call(o,s,r,l.normalizeCol(e),l.getWorldForColumn(e))}}n.pool=new e(n);class a{constructor(t,o,e){this.row=t,this.colFrom=o,this.colTo=e}}const h=new o("0/0/0/0");class c{constructor(t,o,e,l,s,r,i,n){this.x=t,this.ymin=o,this.ymax=e,this.invM=l,this.leftAdjust=s,this.rightAdjust=r,this.leftBound=i,this.rightBound=n}static create(t,o){t[1]>o[1]&&([t,o]=[o,t]);const[e,l]=t,[s,r]=o,i=s-e,n=r-l,a=0!==n?i/n:0,h=(Math.ceil(l)-l)*a,u=(Math.floor(l)-l)*a;return new c(e,Math.floor(l),Math.ceil(r),a,i<0?h:u,i<0?u:h,i<0?s:e,i<0?e:s)}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const u=[[0,0],[0,0],[0,0],[0,0]];class f{constructor(t,o){this.tileInfo=t,this.fullExtent=o,this.scales=[],this._lodInfos=null,this._infoByScale={},this._infoByLevel={};const e=t.lods.slice();e.sort((function(t,o){return o.scale-t.scale}));const l=this._lodInfos=e.map((e=>i.create(t,e,o)));e.forEach(((t,o)=>{this._infoByLevel[t.level]=l[o],this._infoByScale[t.scale]=l[o],this.scales[o]=t.scale}),this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel["number"==typeof t?t:t.level]}getTileBounds(t,o,e=!1){h.set(o);const l=this._infoByLevel[h.level];return l?l.getTileBounds(t,h,e):t}getTileCoords(t,o,e=!1){h.set(o);const l=this._infoByLevel[h.level];return l?l.getTileCoords(t,h,e):t}getTileCoverage(t,o=192,e="closest"){const l="closest"===e?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),s=n.pool.acquire(l),r=this._wrap;let i,h,f,m=1/0,g=-1/0;const d=s.spans;u[0][0]=u[0][1]=u[1][1]=u[3][0]=-o,u[1][0]=u[2][0]=t.size[0]+o,u[2][1]=u[3][1]=t.size[1]+o;for(const o of u)t.toMap(o,o),o[0]=l.getColumnForX(o[0]),o[1]=l.getRowForY(o[1]);const w=[];let y=3;for(let t=0;t<4;t++){if(u[t][1]===u[y][1]){y=t;continue}const o=c.create(u[t],u[y]);m=Math.min(o.ymin,m),g=Math.max(o.ymax,g),void 0===w[o.ymin]&&(w[o.ymin]=[]),w[o.ymin].push(o),y=t}if(null==m||null==g||g-m>100)return null;let M=[];for(i=m;i<g;){null!=w[i]&&(M=M.concat(w[i])),h=1/0,f=-1/0;for(let t=M.length-1;t>=0;t--){const o=M[t];h=Math.min(h,o.getLeftCol()),f=Math.max(f,o.getRightCol())}if(h=Math.floor(h),f=Math.floor(f),i>=l.first[1]&&i<=l.last[1])if(r)if(l.size[0]<l.worldSize[0]){const t=Math.floor(f/l.worldSize[0]);for(let o=Math.floor(h/l.worldSize[0]);o<=t;o++)d.push(new a(i,Math.max(l.getFirstColumnForWorld(o),h),Math.min(l.getLastColumnForWorld(o),f)))}else d.push(new a(i,h,f));else h>l.last[0]||f<l.first[0]||(h=Math.max(h,l.first[0]),f=Math.min(f,l.last[0]),d.push(new a(i,h,f)));i+=1;for(let t=M.length-1;t>=0;t--){const o=M[t];o.ymax>=i?o.incrRow():M.splice(t,1)}}return s}getTileParentId(t){h.set(t);const o=this._infoByLevel[h.level],e=this._lodInfos.indexOf(o)-1;return e<0?null:(this._getTileIdAtLOD(h,this._lodInfos[e],h),h.id)}getTileResolution(t){const o=this._infoByLevel["object"==typeof t?t.level:t];return o?o.resolution:-1}getTileScale(t){const o=this._infoByLevel[t.level];return o?o.scale:-1}intersects(t,o){h.set(o);const e=this._infoByLevel[h.level],l=t.lodInfo;if(l.resolution>e.resolution){this._getTileIdAtLOD(h,l,h);const o=l.denormalizeCol(h.col,h.world);for(const e of t.spans)if(e.row===h.row&&e.colFrom<=o&&e.colTo>=o)return!0}if(l.resolution<e.resolution){const[o,s,r,i]=t.spans.reduce(((t,o)=>(t[0]=Math.min(t[0],o.row),t[1]=Math.max(t[1],o.row),t[2]=Math.min(t[2],o.colFrom),t[3]=Math.max(t[3],o.colTo),t)),[1/0,-1/0,1/0,-1/0]),n=e.denormalizeCol(h.col,h.world),a=l.getColumnForX(e.getXForColumn(n)),c=l.getRowForY(e.getYForRow(h.row)),u=l.getColumnForX(e.getXForColumn(n+1))-1,f=l.getRowForY(e.getYForRow(h.row+1))-1;return!(a>i||u<r||c>s||f<o)}const s=l.denormalizeCol(h.col,h.world);return t.spans.some((t=>t.row===h.row&&t.colFrom<=s&&t.colTo>=s))}normalizeBounds(o,e,l){if(o[0]=e[0],o[1]=e[1],o[2]=e[2],o[3]=e[3],this._wrap){const e=t(this.tileInfo.spatialReference),s=-l*(e.valid[1]-e.valid[0]);o[0]+=s,o[2]+=s}return o}getSmallestInfoForScale(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>o[0])return this._infoByScale[o[0]];for(let e=1;e<o.length-1;e++)if(t>o[e]+1e-6)return this._infoByScale[o[e-1]];return this._infoByScale[o[o.length-1]]}getClosestInfoForScale(t){const o=this.scales;return this._infoByScale[t]||(t=o.reduce(((o,e)=>Math.abs(e-t)<Math.abs(o-t)?e:o),o[0])),this._infoByScale[t]}scaleToLevel(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let e=o.length-1;e>=0;e--)if(t<o[e]){if(e===o.length-1)return this._infoByScale[o[o.length-1]].level;return this._infoByScale[o[e]].level+(o[e]-t)/(o[e]-o[e+1])}return this._infoByScale[o[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,o,e){const l=this._infoByLevel[e.level];return t.set(e),o.resolution<l.resolution?null:(o.resolution===l.resolution||(t.level=o.level,t.col=Math.floor(e.col*l.resolution/o.resolution+.01),t.row=Math.floor(e.row*l.resolution/o.resolution+.01)),t)}}export{f as T,n as a};
