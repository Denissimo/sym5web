/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import t from"../request.js";import{p as e,e as o,a as r}from"./utils5.js";import s from"../rest/support/AddressCandidate.js";import{_ as n}from"./tslib.es6.js";import"../geometry.js";import{a as i}from"./JSONSupport.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{e as p}from"./ensureType.js";import"./Logger.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import{a as u}from"./commonProperties3.js";import c from"../geometry/Point.js";import y from"../geometry/SpatialReference.js";import d from"../geometry/Extent.js";let m=class extends i{constructor(t){super(t),this.address=null,this.apiKey=null,this.categories=null,this.countryCode=null,this.forStorage=null,this.location=null,this.locationType=null,this.magicKey=null,this.maxLocations=null,this.outFields=null,this.outSpatialReference=null,this.searchExtent=null}};n([a({type:Object,json:{write:!0}})],m.prototype,"address",void 0),n([a(u)],m.prototype,"apiKey",void 0),n([a({type:[String],json:{read:{source:"category",reader:t=>t?t.split(","):null},write:{target:"category",writer:(t,e)=>{e.category=t?t.join(","):null}}}})],m.prototype,"categories",void 0),n([a({type:String,json:{write:!0}})],m.prototype,"countryCode",void 0),n([a({type:Boolean,json:{write:!0}})],m.prototype,"forStorage",void 0),n([a({type:c,json:{write:{writer:(t,e)=>{e.location=t?t.clone().normalize():null}}}})],m.prototype,"location",void 0),n([a({type:String,json:{write:!0}})],m.prototype,"locationType",void 0),n([a({type:String,json:{write:!0}})],m.prototype,"magicKey",void 0),n([a({type:Number,json:{write:!0}})],m.prototype,"maxLocations",void 0),n([a({type:[String],json:{write:{writer:(t,e)=>{e.outFields=t?t.join(","):null}}}})],m.prototype,"outFields",void 0),n([a({type:y,json:{read:{source:"outSR"},write:{target:"outSR"}}})],m.prototype,"outSpatialReference",void 0),n([a({type:d,json:{write:{writer:(t,e)=>{const o=t?t.shiftCentralMeridian():null;e.searchExtent=o}}}})],m.prototype,"searchExtent",void 0),m=n([l("esri.rest.support.AddressToLocationsParameters")],m),m.from=p(m);var f=m;async function g(s,n,i){n=f.from(n);const a=e(s),{address:p,...l}=n.toJSON(),u={...p,...l,f:"json"},c=o({...a.query,...u}),y=r(c,i),d=`${a.path}/findAddressCandidates`;return t(d,y).then(j)}function j({data:t}){if(!t)return[];const{candidates:e,spatialReference:o}=t;return e?e.map((t=>{if(!t)return;const{extent:e,location:r}=t,n=!e||function(t){return t&&"number"==typeof t.xmin&&"number"==typeof t.ymin&&"number"==typeof t.xmax&&"number"==typeof t.ymax}(e);return function(t){return t&&"number"==typeof t.x&&"number"==typeof t.y}(r)&&n?(e&&(e.spatialReference=o),r.spatialReference=o,s.fromJSON(t)):void 0})):[]}let h=class extends i{constructor(t){super(t),this.addresses=null,this.categories=null,this.countryCode=null,this.locationType=null,this.outSpatialReference=null}};n([a({type:[Object],json:{read:{reader:t=>t&&t.records?t.records.map((t=>t.attributes)):null},write:{writer:(t,e)=>{const o=[];Array.isArray(t)&&t.forEach((t=>{o.push({attributes:t})})),e.addresses={records:o}}}}})],h.prototype,"addresses",void 0),n([a({type:[String],json:{read:{source:"category",reader:t=>t?t.split(","):null},write:{target:"category",writer:(t,e)=>{e.category=t?t.join(","):null}}}})],h.prototype,"categories",void 0),n([a({type:String,json:{read:{source:"sourceCountry"},write:{target:"sourceCountry"}}})],h.prototype,"countryCode",void 0),n([a({type:String,json:{write:!0}})],h.prototype,"locationType",void 0),n([a({type:y,json:{read:{source:"outSR"},write:{target:"outSR"}}})],h.prototype,"outSpatialReference",void 0),h=n([l("esri.rest.support.AddressesToLocationsParameters")],h),h.from=p(h);var S=h;async function v(s,n,i){n=S.from(n);const a=e(s),p={...n.toJSON(),f:"json"},l=o({...a.query,...p}),u=r(l,i),c=`${a.path}/geocodeAddresses`;return t(c,u).then(w)}function w(t){const{data:e}=t;if(!e)return[];const{locations:o,spatialReference:r}=e;return o?o.map((t=>{const{location:e}=t;return e&&(e.spatialReference=r),s.fromJSON(t)})):[]}let x=class extends i{constructor(t){super(t),this.apiKey=null,this.location=null,this.locationType=null,this.outSpatialReference=null}};n([a(u)],x.prototype,"apiKey",void 0),n([a({type:c,json:{write:{writer:(t,e)=>{const o=t?t.clone().normalize():null,r=void 0!==o;e.location=r?o:null}}}})],x.prototype,"location",void 0),n([a({type:String,json:{write:!0}})],x.prototype,"locationType",void 0),n([a({type:y,json:{read:{source:"outSR"},write:{target:"outSR"}}})],x.prototype,"outSpatialReference",void 0),x=n([l("esri.rest.support.LocationToAddressParameters")],x),x.from=p(x);var R=x;async function b(s,n,i){n=R.from(n);const a=e(s),p={...n.toJSON(),f:"json"},l=o({...a.query,...p}),u=r(l,i),c=`${a.path}/reverseGeocode`;return t(c,u).then(C)}function C({data:t}){if(!t)return;const{address:e,location:o}=t,r=e&&e.Match_addr||"";return s.fromJSON({address:r,attributes:e||{},location:o,score:100})}let N=class extends i{constructor(t){super(t),this.isCollection=null,this.magicKey=null,this.text=null}};n([a({type:Boolean,json:{write:!0}})],N.prototype,"isCollection",void 0),n([a({type:String,json:{write:!0}})],N.prototype,"magicKey",void 0),n([a({type:String,json:{write:!0}})],N.prototype,"text",void 0),N=n([l("esri.rest.support.SuggestionCandidate")],N);var O=N;let K=class extends i{constructor(t){super(t),this.apiKey=null,this.categories=null,this.countryCode=null,this.location=null,this.maxSuggestions=null,this.outSpatialReference=null,this.searchExtent=null,this.text=null}};n([a(u)],K.prototype,"apiKey",void 0),n([a({type:[String],json:{read:{source:"category",reader:t=>t?t.split(","):null},write:{target:"category",writer:(t,e)=>{e.category=t?t.join(","):null}}}})],K.prototype,"categories",void 0),n([a({type:String,json:{write:!0}})],K.prototype,"countryCode",void 0),n([a({type:c,json:{write:{writer:(t,e)=>{e.location=t?t.clone().normalize():null}}}})],K.prototype,"location",void 0),n([a({type:Number,json:{write:!0}})],K.prototype,"maxSuggestions",void 0),n([a({type:y,json:{read:{source:"outSR"},write:{target:"outSR"}}})],K.prototype,"outSpatialReference",void 0),n([a({type:d,json:{write:{writer:(t,e)=>{const o=t?t.shiftCentralMeridian():null;e.searchExtent=JSON.stringify(o)}}}})],K.prototype,"searchExtent",void 0),n([a({type:String,json:{write:!0}})],K.prototype,"text",void 0),K=n([l("esri.rest.support.SuggestLocationsParameters")],K),K.from=p(K);var T=K;async function A(s,n,i){const a=e(s),p={...(n=T.from(n)).toJSON(),f:"json"},l=o({...a.query,...p}),u=r(l,i),c=`${a.path}/suggest`;return t(c,u).then(J)}function J(t){const{data:e}=t;if(!e)return[];const{suggestions:o}=e;return o?o.map((t=>new O(t))):[]}export{f as A,R as L,T as S,g as a,v as b,b as l,A as s};
