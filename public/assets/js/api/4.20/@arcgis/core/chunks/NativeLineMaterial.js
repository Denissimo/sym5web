/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{L as e}from"./Logger.js";import{i as t,u as s,b as i}from"../core/lang.js";import{d as r}from"./screenUtils.js";import{c as a}from"./vec2.js";import{e as o,s as n,d as l,f as p,g as c,j as u,l as d,w as h,b as f}from"./mathUtils.js";import{c as m,d as g,f as v,a as b}from"./lineSegment.js";import{c as P,f as x,s as C,n as y}from"./plane.js";import{a as E}from"./BufferView.js";import{c as w}from"./geometryDataUtils.js";import{S as j,T as S,V as _,g as O,n as T,m as R,y as A,p as q,a as U,b as B,P as L,D as V,c as H,E as I,a1 as M,a3 as z,as as D,I as N,ag as $,K as F,R as W,a8 as G,at as X,a6 as K,af as k,a9 as J}from"./VertexColor.glsl.js";import{h as Q}from"./Util.js";import{g as Y,j as Z,D as ee}from"./ColorMaterial.js";import{i as te}from"./utils4.js";import{_ as se}from"./tslib.es6.js";import{L as ie}from"./RibbonLineMaterial.js";import{s as re,m as ae,d as oe,c as ne}from"./VertexArrayObject.js";var le=Object.freeze({__proto__:null,build:function(e){const t=new j;return t.include(S,{linearDepth:!1}),t.include(_,e),t.include(ie,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(O`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),e.stippleEnabled&&(t.attributes.add("auxpos1","vec3"),t.vertex.uniforms.add("ndcToPixel","vec2"),t.vertex.code.add(O`
    vec4 vpos2 = transformPosition(proj, view, auxpos1);
    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);

    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;
    ${e.stippleIntegerRepeatsEnabled?"stipplePatternUv = floor(stipplePatternUv + 0.5);":""}

    // Cancel out perspective correct interpolation because we want this length the really represent
    // the screen distance
    stipplePatternUv *= gl_Position.w;
    `)),t.vertex.code.add(O`}`),4===e.output&&t.include(T),t.include(R,e),t.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),t.fragment.code.add(O`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${e.attributeColor?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${O.float(A)}) {
      discard;
    }

    ${0===e.output?O`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${4===e.output?O`outputHighlight();`:""}
  }
  `),t}});class pe extends B{constructor(e,t,s){super(e,t,s),this.stipplePattern=null,this.stippleTextureBind=null,this.stippleTextureRepository=e.stippleTextureRepository}initializeProgram(e){const t=pe.shader.get(),s=this.configuration,i=t.build({output:s.output,attributeColor:s.vertexColors,slicePlaneEnabled:s.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,stippleEnabled:s.stippleEnabled,stippleOffColorEnabled:s.stippleOffColorEnabled,stippleUVMaxEnabled:!1,stippleIntegerRepeatsEnabled:s.stippleIntegerRepeatsEnabled});return new L(e.rctx,i,V)}dispose(){super.dispose(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,i){if(H(this.program,i.camera.projectionMatrix),this.stipplePattern!==e.stipplePattern){const t=e.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,t),this.stipplePattern=t}if(this.configuration.stippleEnabled){const e=t(this.stippleTextureBind)?this.stippleTextureBind(this.program)*i.camera.pixelRatio:1;this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/e),this.program.setUniform2f("ndcToPixel",i.camera.fullViewport[2]/2,i.camera.fullViewport[3]/2)}if(this.program.setUniform4fv("constantColor",e.color),this.program.setUniform1f("alphaCoverage",Math.min(1,e.width*i.camera.pixelRatio)),this.configuration.stippleOffColorEnabled){const t=s(e.stippleOffColor);this.program.setUniform4f("stippleOffColor",t[0],t[1],t[2],t.length>3?t[3]:1)}4===this.configuration.output&&I(this.program,i)}bindDraw(e){M(this.program,e),z(this.program,this.configuration,e),this.program.rebindTextures()}initializePipeline(){const e=this.configuration,t=re(770,1,771,771),s=(t,s=null,i=null)=>ae({blending:s,depthTest:D,depthWrite:i,colorWrite:oe,stencilWrite:e.sceneHasOcludees?N:null,stencilTest:e.sceneHasOcludees?t?$:F:null});return 0===e.output?(this._occludeePipelineState=s(!0,e.transparent||e.stippleEnabled?t:null,ne),s(!1,e.transparent||e.stippleEnabled?t:null,ne)):s(!1)}get primitiveType(){return 1}getPipelineState(e){return e?this._occludeePipelineState:this.pipeline}}pe.shader=new W(le,(()=>Promise.resolve().then((function(){return le}))));class ce extends U{constructor(){super(...arguments),this.output=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleIntegerRepeatsEnabled=!1,this.sceneHasOcludees=!1}}se([q({count:8})],ce.prototype,"output",void 0),se([q()],ce.prototype,"slicePlaneEnabled",void 0),se([q()],ce.prototype,"vertexColors",void 0),se([q()],ce.prototype,"transparent",void 0),se([q()],ce.prototype,"stippleEnabled",void 0),se([q()],ce.prototype,"stippleOffColorEnabled",void 0),se([q()],ce.prototype,"stippleIntegerRepeatsEnabled",void 0),se([q()],ce.prototype,"sceneHasOcludees",void 0);const ue=e.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class de extends G{constructor(e){super(e,me),this.techniqueConfig=new ce}getTechniqueConfig(e){this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;const s=t(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=s,this.techniqueConfig.stippleOffColorEnabled=s&&t(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=s&&this.params.stippleIntegerRepeats,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,s,i,r,a,o,n,l){l?X(e,i,a,1,o):this.intersectLineGeometry(e,t,s,i,o)}intersectLineGeometry(e,t,s,i,r){if(!i.options.selectionMode||te(t))return;if(!Q(s))return void ue.error("intersection assumes a translation-only matrix");const f=e.vertexAttributes.get("position").data,m=i.camera,P=Se;a(P,i.point);o(_e[0],P[0]-2,P[1]+2,0),o(_e[1],P[0]+2,P[1]+2,0),o(_e[2],P[0]+2,P[1]-2,0),o(_e[3],P[0]-2,P[1]-2,0);for(let e=0;e<4;e++)if(!m.unprojectFromRenderScreen(_e[e],Oe[e]))return;x(m.eye,Oe[0],Oe[1],Te),x(m.eye,Oe[1],Oe[2],Re),x(m.eye,Oe[2],Oe[3],Ae),x(m.eye,Oe[3],Oe[0],qe);let E=Number.MAX_VALUE;for(let e=0;e<f.length-5;e+=3){if(ge[0]=f[e]+s[12],ge[1]=f[e+1]+s[13],ge[2]=f[e+2]+s[14],ve[0]=f[e+3]+s[12],ve[1]=f[e+4]+s[13],ve[2]=f[e+5]+s[14],C(Te,ge)<0&&C(Te,ve)<0||C(Re,ge)<0&&C(Re,ve)<0||C(Ae,ge)<0&&C(Ae,ve)<0||C(qe,ge)<0&&C(qe,ve)<0)continue;if(m.projectToRenderScreen(ge,xe),m.projectToRenderScreen(ve,Ce),xe[2]<0&&Ce[2]>0){n(be,ge,ve);const e=m.frustum,t=-C(e[4],ge)/l(be,y(e[4]));p(be,be,t),c(ge,ge,be),m.projectToRenderScreen(ge,xe)}else if(xe[2]>0&&Ce[2]<0){n(be,ve,ge);const e=m.frustum,t=-C(e[4],ve)/l(be,y(e[4]));p(be,be,t),c(ve,ve,be),m.projectToRenderScreen(ve,Ce)}else if(xe[2]<0&&Ce[2]<0)continue;xe[2]=0,Ce[2]=0;const t=g(v(xe,Ce,we),P);t<E&&(E=t,u(ye,ge),u(Ee,ve))}const w=i.rayBeginPoint,j=i.rayEndPoint;if(E<4){let e=Number.MAX_VALUE;if(b(v(ye,Ee,we),v(w,j,je),Pe)){n(Pe,Pe,w);const t=d(Pe);p(Pe,Pe,1/t),e=t/h(w,j)}r(e,Pe)}}computeAttachmentOrigin(e,t){const s=e.vertexAttributes;if(!s)return!1;const i=s.get("position");return w(i,null,!1,t)}createBufferWriter(){const e=this.params.vertexColors?Y:Z;return i(this.params.stipplePattern)?new ee(e):new fe(e.clone().vec3f("auxpos1"))}getGLMaterial(e){return 0===e.output||4===e.output?new he(e):void 0}}class he extends K{constructor(e){super(e),this.updateParameters()}updateParameters(){this._technique=this._techniqueRep.releaseAndAcquire(pe,this._material.getTechniqueConfig(this._output),this._technique)}beginSlot(e){return 3===e}_updateOccludeeState(e){e.hasOccludees!==this._material.params.sceneHasOcludees&&(this._material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())}ensureParameters(e){0===this._output&&this._updateOccludeeState(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}getPipelineState(e,t){return this._technique.getPipelineState(t)}}class fe{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,s,i){k(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,s,i),this.writeAuxpos1(e,t,s,i)}writeAuxpos1(e,t,s,i){const r=s.getField("auxpos1",E),a=t.indices.get("position"),o=t.vertexAttributes.get("position").data,n=e.transformation,l=r.typedBufferStride,p=r.typedBuffer;i*=l;for(let e=0;e<a.length;e+=2){const t=3*a[e],s=o[t],r=o[t+1],c=o[t+2],u=n[0]*s+n[4]*r+n[8]*c+n[12],d=n[1]*s+n[5]*r+n[9]*c+n[13],h=n[2]*s+n[6]*r+n[10]*c+n[14];for(let e=0;e<2;++e)p[i]=u,p[i+1]=d,p[i+2]=h,i+=l}}}const me={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...J},ge=f(),ve=f(),be=f(),Pe=f(),xe=r(),Ce=r(),ye=f(),Ee=f(),we=m(),je=m(),Se=f(),_e=[r(),r(),r(),r()],Oe=[f(),f(),f(),f()],Te=P(),Re=P(),Ae=P(),qe=P();export{de as N};
