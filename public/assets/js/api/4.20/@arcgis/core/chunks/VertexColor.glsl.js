/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{L as e}from"./Logger.js";import{l as t,b as i,i as r}from"../core/lang.js";import{H as s,b as n,p as a,u as o,h as c,o as l,S as u,k as d,c as f,e as h,a as m,n as p,s as g,Z as v}from"./mathUtils.js";import{P as _}from"../core/scheduling.js";import{P as x}from"./Program.js";import{j as b,V as P,B as y,s as F,a as S,c as T}from"./VertexArrayObject.js";import{t as M,q as A}from"./mat4.js";import{c as w}from"./mat4f32.js";import{a as I}from"./Util.js";import{C as O,i as D}from"./utils4.js";import{g as B,a as C,b as L}from"./geometryDataUtils.js";import{T as z}from"./Texture.js";import{c as E,m as H,n as U}from"./aaBoundingBox.js";import{g as $,b as k,e as V,a as R}from"./BufferView.js";import{f as j}from"./vec4f64.js";function G(e,...t){let i="";for(let r=0;r<t.length;r++)i+=e[r]+t[r];return i+=e[e.length-1],i}function N(e,t){t.linearDepth?e.vertex.code.add(G`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;
return proj * eye;
}`):e.vertex.code.add(G`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}!function(e){e.int=function(e){return Math.round(e).toString()},e.float=function(e){return e.toPrecision(8)}}(G||(G={}));const q=e.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class W{constructor(){this.includedModules=new Map}include(e,t){this.includedModules.has(e)?this.includedModules.get(e)!==t&&q.error("Trying to include shader module multiple times with different sets of options."):(this.includedModules.set(e,t),e(this.builder,t))}}class Y extends W{constructor(){super(...arguments),this.vertex=new Z,this.fragment=new Z,this.attributes=new J,this.varyings=new Q,this.extensions=new ee,this.constants=new te}get fragmentUniforms(){return this.fragment.uniforms}get builder(){return this}generateSource(e){const t=this.extensions.generateSource(e),i=this.attributes.generateSource(e),r=this.varyings.generateSource(),s="vertex"===e?this.vertex:this.fragment,n=s.uniforms.generateSource(),a=s.code.generateSource(),o="vertex"===e?re:ie,c=this.constants.generateSource().concat(s.constants.generateSource());return`\n${t.join("\n")}\n\n${o}\n\n${c.join("\n")}\n\n${n.join("\n")}\n\n${i.join("\n")}\n\n${r.join("\n")}\n\n${a.join("\n")}`}}class K{constructor(){this._entries=new Map}add(e,t,i){const r=`${e}_${t}_${i}`;return this._entries.set(r,{name:e,type:t,arraySize:i}),this}generateSource(){return Array.from(this._entries.values()).map((e=>{return`uniform ${e.type} ${e.name}${t=e.arraySize,t?`[${t}]`:""};`;var t}))}get entries(){return Array.from(this._entries.values())}}class X{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class Z extends W{constructor(){super(...arguments),this.uniforms=new K,this.code=new X,this.constants=new te}get builder(){return this}}class J{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`attribute ${e[1]} ${e[0]};`))}}class Q{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(){return this._entries.map((e=>`varying ${e[1]} ${e[0]};`))}}class ee{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t="vertex"===e?ee.ALLOWLIST_VERTEX:ee.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>t.includes(e))).map((e=>`#extension ${e} : enable`))}}ee.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],ee.ALLOWLIST_VERTEX=[];class te{constructor(){this._entries=[]}add(e,t,i){let r="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":r=te.numberToFloatStr(i);break;case"int":r=te.numberToIntStr(i);break;case"bool":r=i.toString();break;case"vec2":r=`vec2(${te.numberToFloatStr(i[0])},                            ${te.numberToFloatStr(i[1])})`;break;case"vec3":r=`vec3(${te.numberToFloatStr(i[0])},                            ${te.numberToFloatStr(i[1])},                            ${te.numberToFloatStr(i[2])})`;break;case"vec4":r=`vec4(${te.numberToFloatStr(i[0])},                            ${te.numberToFloatStr(i[1])},                            ${te.numberToFloatStr(i[2])},                            ${te.numberToFloatStr(i[3])})`;break;case"ivec2":r=`ivec2(${te.numberToIntStr(i[0])},                             ${te.numberToIntStr(i[1])})`;break;case"ivec3":r=`ivec3(${te.numberToIntStr(i[0])},                             ${te.numberToIntStr(i[1])},                             ${te.numberToIntStr(i[2])})`;break;case"ivec4":r=`ivec4(${te.numberToIntStr(i[0])},                             ${te.numberToIntStr(i[1])},                             ${te.numberToIntStr(i[2])},                             ${te.numberToIntStr(i[3])})`;break;case"mat2":case"mat3":case"mat4":r=`${t}(${Array.prototype.map.call(i,(e=>te.numberToFloatStr(e))).join(", ")})`}return this._entries.push(`const ${t} ${e} = ${r};`),this}static numberToIntStr(e){return e.toFixed(0)}static numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const ie="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif",re="precision highp float;\nprecision highp sampler2D;";class se{constructor(e,t){this._module=e,this._loadModule=t}get(){return this._module}async reload(){return this._module=await this._loadModule(),this._module}}class ne{constructor(e,t,i=(()=>this.dispose())){this.release=i,t&&(this._config=t.snapshot()),this._program=this.initializeProgram(e),this._pipeline=this.initializePipeline(e)}dispose(){this._program=t(this._program),this._pipeline=this._config=null}reload(e){t(this._program),this._program=this.initializeProgram(e)}get program(){return this._program}get pipeline(){return this._pipeline}get key(){return this._config.key}get configuration(){return this._config}bindPass(e,t){}bindMaterial(e,t){}bindDraw(e,t,i){}bindPipelineState(e){e.setPipelineState(this.pipeline)}ensureAttributeLocations(e){this.program.assertCompatibleVertexAttributeLocations(e)}get primitiveType(){return 4}}class ae{constructor(){this._key="",this._keyDirty=!1,this._parameterBits=this._parameterBits.map((()=>0))}get key(){return this._keyDirty&&(this._keyDirty=!1,this._key=String.fromCharCode.apply(String,this._parameterBits)),this._key}snapshot(){const e=this._parameterNames,t={key:this.key};for(const i of e)t[i]=this[i];return t}}function oe(e={}){return(t,i)=>{var r,n;t._parameterNames=null!=(r=t._parameterNames)?r:[],t._parameterNames.push(i);const a=t._parameterNames.length-1,o=e.count||2,c=Math.ceil(s(o)),l=null!=(n=t._parameterBits)?n:[0];let u=0;for(;l[u]+c>16;)u++,u>=l.length&&l.push(0);t._parameterBits=l;const d=l[u],f=(1<<c)-1<<d;l[u]+=c,Object.defineProperty(t,i,{get(){return this[a]},set(e){if(this[a]!==e&&(this[a]=e,this._keyDirty=!0,this._parameterBits[u]=this._parameterBits[u]&~f|+e<<d&f,"number"!=typeof e&&"boolean"!=typeof e))throw"Configuration value for "+i+" must be boolean or number, got "+typeof e}})}}const ce=new Map([["position",0],["normal",1],["uv0",2],["color",3],["size",4],["tangent",4],["auxpos1",5],["symbolColor",5],["auxpos2",6],["featureAttribute",6],["instanceFeatureAttribute",6],["instanceColor",7],["model",8],["modelNormal",12],["modelOriginHi",11],["modelOriginLo",15]]);class le extends x{constructor(e,t,i){super(e,t.generateSource("vertex"),t.generateSource("fragment"),i),this._textures=new Map,this._freeTextureUnits=new _({deallocator:null}),this._fragmentUniforms=b()?t.fragmentUniforms.entries:null}stop(){this._textures.clear(),this._freeTextureUnits.clear()}bindTexture(e,t){if(i(e)||null==e.glName){const e=this._textures.get(t);return e&&(this._context.bindTexture(null,e.unit),this._freeTextureUnit(e),this._textures.delete(t)),null}let r=this._textures.get(t);return null==r?(r=this._allocTextureUnit(e),this._textures.set(t,r)):r.texture=e,this._context.useProgram(this),this.setUniform1i(t,r.unit),this._context.bindTexture(e,r.unit),r.unit}rebindTextures(){this._context.useProgram(this),this._textures.forEach(((e,t)=>{this._context.bindTexture(e.texture,e.unit),this.setUniform1i(t,e.unit)})),r(this._fragmentUniforms)&&this._fragmentUniforms.forEach((e=>{if(("sampler2D"===e.type||"samplerCube"===e.type)&&!this._textures.has(e.name))throw new Error(`Texture sampler ${e.name} has no bound texture`)}))}_allocTextureUnit(e){return{texture:e,unit:0===this._freeTextureUnits.length?this._textures.size:this._freeTextureUnits.pop()}}_freeTextureUnit(e){this._freeTextureUnits.push(e.unit)}}function ue(e,t,i){e.setUniform3f("camPos",i[3]-t[0],i[7]-t[1],i[11]-t[2])}function de(e,t){e.setUniformMatrix4fv("proj",t)}function fe(e,t){e.setUniform2fv("nearFar",t)}function he(e,t,i){M(ge,i,t),e.setUniform3fv("localOrigin",t),e.setUniformMatrix4fv("view",ge)}function me(e,t){he(e,t.origin,t.camera.viewMatrix)}function pe(e,t){e.setUniform4fv("viewport",t.camera.fullViewport)}const ge=w();class ve{constructor(e,t,i,r){this.primitiveIndices=e,this._numIndexPerPrimitive=t,this.indices=i,this.position=r,this.center=n(),I(e.length>=1),I(i.length%this._numIndexPerPrimitive==0),I(i.length>=e.length*this._numIndexPerPrimitive),I(3===r.size||4===r.size);const{data:s,size:l}=r,u=e.length;let d=l*i[this._numIndexPerPrimitive*e[0]];_e.clear(),_e.push(d),this.bbMin=a(s[d],s[d+1],s[d+2]),this.bbMax=o(this.bbMin);for(let t=0;t<u;++t){const r=this._numIndexPerPrimitive*e[t];for(let e=0;e<this._numIndexPerPrimitive;++e){d=l*i[r+e],_e.push(d);let t=s[d];this.bbMin[0]=Math.min(t,this.bbMin[0]),this.bbMax[0]=Math.max(t,this.bbMax[0]),t=s[d+1],this.bbMin[1]=Math.min(t,this.bbMin[1]),this.bbMax[1]=Math.max(t,this.bbMax[1]),t=s[d+2],this.bbMin[2]=Math.min(t,this.bbMin[2]),this.bbMax[2]=Math.max(t,this.bbMax[2])}}c(this.center,this.bbMin,this.bbMax,.5),this.radius=.5*Math.max(Math.max(this.bbMax[0]-this.bbMin[0],this.bbMax[1]-this.bbMin[1]),this.bbMax[2]-this.bbMin[2]);let f=this.radius*this.radius;for(let e=0;e<_e.length;++e){d=_e.getItemAt(e);const t=s[d]-this.center[0],i=s[d+1]-this.center[1],r=s[d+2]-this.center[2],n=t*t+i*i+r*r;if(n<=f)continue;const a=Math.sqrt(n),o=.5*(a-this.radius);this.radius=this.radius+o,f=this.radius*this.radius;const c=o/a;this.center[0]+=t*c,this.center[1]+=i*c,this.center[2]+=r*c}_e.clear()}getCenter(){return this.center}getBSRadius(){return this.radius}getBBMin(){return this.bbMin}getBBMax(){return this.bbMax}getChildren(){if(this._children)return this._children;if(l(this.bbMin,this.bbMax)>1){const e=c(n(),this.bbMin,this.bbMax,.5),t=this.primitiveIndices.length,i=new Uint8Array(t),r=new Array(8);for(let e=0;e<8;++e)r[e]=0;const{data:s,size:a}=this.position;for(let n=0;n<t;++n){let t=0;const o=this._numIndexPerPrimitive*this.primitiveIndices[n];let c=a*this.indices[o],l=s[c],u=s[c+1],d=s[c+2];for(let e=1;e<this._numIndexPerPrimitive;++e){c=a*this.indices[o+e];const t=s[c],i=s[c+1],r=s[c+2];t<l&&(l=t),i<u&&(u=i),r<d&&(d=r)}l<e[0]&&(t|=1),u<e[1]&&(t|=2),d<e[2]&&(t|=4),i[n]=t,++r[t]}let o=0;for(let e=0;e<8;++e)r[e]>0&&++o;if(o<2)return;const l=new Array(8);for(let e=0;e<8;++e)l[e]=r[e]>0?new Uint32Array(r[e]):void 0;for(let e=0;e<8;++e)r[e]=0;for(let e=0;e<t;++e){const t=i[e];l[t][r[t]++]=this.primitiveIndices[e]}this._children=new Array(8);for(let e=0;e<8;++e)void 0!==l[e]&&(this._children[e]=new ve(l[e],this._numIndexPerPrimitive,this.indices,this.position))}return this._children}static prune(){_e.prune()}}const _e=new _({deallocator:null});class xe extends O{constructor(e,t=[],i=0,r=-1){super(),this._primitiveType=i,this.edgeIndicesLength=r,this.type=2,this._vertexAttributes=new Map,this._indices=new Map,this._boundingInfo=null;for(const[t,i]of e)i&&this._vertexAttributes.set(t,{...i});if(null==t||0===t.length){const e=function(e){const t=e.values().next().value;if(null==t)return 0;return t.data.length/t.size}(this._vertexAttributes),t=B(e);this.edgeIndicesLength=this.edgeIndicesLength<0?e:this.edgeIndicesLength;for(const e of this._vertexAttributes.keys())this._indices.set(e,t)}else for(const[e,i]of t)i&&(this._indices.set(e,be(i)),"position"===e&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._indices.get(e).length:this.edgeIndicesLength))}get vertexAttributes(){return this._vertexAttributes}getMutableAttribute(e){const t=this._vertexAttributes.get(e);return t&&!t.exclusive&&(t.data=Array.from(t.data),t.exclusive=!0),t}get indices(){return this._indices}get indexCount(){const e=this._indices.values().next().value;return e?e.length:0}get primitiveType(){return this._primitiveType}get faceCount(){return this.indexCount/3}get boundingInfo(){return i(this._boundingInfo)&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(e){return 0===this.primitiveType?this.computeAttachmentOriginTriangles(e):this.computeAttachmentOriginPoints(e)}computeAttachmentOriginTriangles(e){const t=this.indices.get("position"),i=this.vertexAttributes.get("position");return C(i,t,e)}computeAttachmentOriginPoints(e){const t=this.indices.get("position"),i=this.vertexAttributes.get("position");return L(i,t,e)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const e=this.indices.get("position");if(0===e.length)return null;const t=0===this.primitiveType?3:1;I(e.length%t==0,"Indexing error: "+e.length+" not divisible by "+t);const i=B(e.length/t),r=this.vertexAttributes.get("position");return new ve(i,t,e,r)}}function be(e){if(e.BYTES_PER_ELEMENT===Uint16Array.BYTES_PER_ELEMENT)return e;for(const t of e)if(t>=65536)return e;return new Uint16Array(e)}function Pe(e){e.code.add(G`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`)}const ye=[{name:"position",count:2,type:5126,offset:0,stride:8,normalized:!1}],Fe=[{name:"position",count:2,type:5126,offset:0,stride:16,normalized:!1},{name:"uv0",count:2,type:5126,offset:8,stride:16,normalized:!1}];function Se(e,t=ye,i=ce,r=-1,s=1){let n=null;switch(t){case Fe:n=new Float32Array([r,r,0,0,s,r,1,0,r,s,0,1,s,s,1,1]);break;case ye:default:n=new Float32Array([r,r,s,r,r,s,s,s])}return new P(e,i,{geometry:t},{geometry:y.createVertex(e,35044,n)})}function Te(e,t=ye,i=ce){const r=new Float32Array([-1,-1,3,-1,-1,3]);return new P(e,i,{geometry:t},{geometry:y.createVertex(e,35044,r)})}function Me(e,t=4){return new z(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:t,height:t})}function Ae(e,t,i=4){const r=new Uint8Array(i*i*4);for(let e=0;e<r.length;e+=4)r[e+0]=255*t[0],r[e+1]=255*t[1],r[e+2]=255*t[2],r[e+3]=255*t[3];return new z(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:i,height:i},r)}function we(e){return new z(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1},new Uint8Array([255,255,255,255]))}function Ie(e,t){return new Ee(e,He,t)}function Oe(e,t){const{curvatureDependent:i,scaleStart:r,scaleFallOffRange:s}=He;return new Ee(e,{curvatureDependent:{min:{curvature:i.min.curvature,tiltAngle:i.min.tiltAngle,scaleFallOffFactor:Ue.curvatureDependent.min.scaleFallOffFactor},max:{curvature:i.max.curvature,tiltAngle:i.max.tiltAngle,scaleFallOffFactor:Ue.curvatureDependent.max.scaleFallOffFactor}},scaleStart:r,scaleFallOffRange:s,minPixelSize:Ue.minPixelSize},t)}function De(e,t,i){const r=i.parameters,s=i.paddingPixelsOverride;return $e.scale=Math.min(r.divisor/(t-r.offset),1),$e.factor=function(e){return Math.abs(e*e*e)}(e),$e.minPixelSize=r.minPixelSize,$e.paddingPixels=s,$e}function Be(e,t){return 0===e?t.minPixelSize:t.minPixelSize*(1+2*t.paddingPixels/e)}function Ce(e,t){return Math.max(u(e*t.scale,e,t.factor),Be(e,t))}function Le(e,t,i,r){r.scale=function(e,t,i){const r=De(e,t,i);return r.minPixelSize=0,r.paddingPixels=0,Ce(1,r)}(e,t,i),r.factor=0,r.minPixelSize=i.parameters.minPixelSize,r.paddingPixels=i.paddingPixelsOverride}function ze(e,t,i=[0,0]){const r=Math.min(Math.max(t.scale,Be(e[1],t)/e[1]),1);return i[0]=e[0]*r,i[1]=e[1]*r,i}class Ee{constructor(e,t,i,r={camera:{distance:0,fovY:0},divisor:0,offset:0,minPixelSize:0,paddingPixels:0},s){this.viewingMode=e,this.description=t,this.ellipsoidRadius=i,this.parameters=r,this._paddingPixelsOverride=s,2===this.viewingMode?(this.coverageCompensation=this.surfaceCoverageCompensationLocal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersLocal):(this.coverageCompensation=this.surfaceCoverageCompensationGlobal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersGlobal)}get paddingPixelsOverride(){return this._paddingPixelsOverride||this.parameters.paddingPixels}update(e){return(!this.parameters||this.parameters.camera.fovY!==e.fovY||this.parameters.camera.distance!==e.distance)&&(this.calculateParameters(e,this.ellipsoidRadius,this.parameters),!0)}overridePadding(e){return e!==this.paddingPixelsOverride?new Ee(this.viewingMode,this.description,this.ellipsoidRadius,this.parameters,e):this}calculateParameters(e,t,i){const{scaleStart:r,scaleFallOffRange:s,minPixelSize:n}=this.description,{fovY:a,distance:o}=e,c=this.calculateCurvatureDependentParameters(e,t),l=this.coverageCompensation(e,t,c),{tiltAngle:u,scaleFallOffFactor:d}=c,f=Math.sin(u)*o,h=.5*Math.PI-u-a*(.5-r*l),m=f/Math.cos(h),p=h+a*s*l,g=(m-d*(f/Math.cos(p)))/(1-d);return i.camera.fovY=e.fovY,i.camera.distance=e.distance,i.offset=g,i.divisor=m-g,i.minPixelSize=n,i}calculateCurvatureDependentParametersLocal(e,t,i=ke){return i.tiltAngle=this.description.curvatureDependent.min.tiltAngle,i.scaleFallOffFactor=this.description.curvatureDependent.min.scaleFallOffFactor,i}calculateCurvatureDependentParametersGlobal(e,t,i=ke){const r=this.description.curvatureDependent,s=1+e.distance/t,n=Math.sqrt(s*s-1),[a,o]=[r.min.curvature,r.max.curvature],c=f((n-a)/(o-a),0,1),[l,d]=[r.min,r.max];return i.tiltAngle=u(l.tiltAngle,d.tiltAngle,c),i.scaleFallOffFactor=u(l.scaleFallOffFactor,d.scaleFallOffFactor,c),i}surfaceCoverageCompensationLocal(e,t,i){return(e.fovY-i.tiltAngle)/e.fovY}surfaceCoverageCompensationGlobal(e,t,i){const r=t*t,s=i.tiltAngle+.5*Math.PI,{fovY:n,distance:a}=e,o=a*a+r-2*Math.cos(s)*a*t,c=Math.sqrt(o),l=Math.sqrt(o-r);return(Math.acos(l/c)-Math.asin(t/(c/Math.sin(s)))+.5*n)/n}}const He={curvatureDependent:{min:{curvature:d(10),tiltAngle:d(12),scaleFallOffFactor:.5},max:{curvature:d(70),tiltAngle:d(40),scaleFallOffFactor:.8}},scaleStart:.3,scaleFallOffRange:.65,minPixelSize:0},Ue={curvatureDependent:{min:{scaleFallOffFactor:.7},max:{scaleFallOffFactor:.95}},minPixelSize:14};const $e={scale:0,factor:0,minPixelSize:0,paddingPixels:0},ke={tiltAngle:0,scaleFallOffFactor:0},Ve=e=>class extends e{constructor(){super(...arguments),this._isDisposed=!1}dispose(){for(const t of null!=(e=this._managedDisposables)?e:[]){var e;const i=this[t];this[t]=null,i&&"function"==typeof i.dispose&&i.dispose()}this._isDisposed=!0}get isDisposed(){return this._isDisposed}};class Re extends(Ve(class{})){}function je(){return(e,t)=>{var i,r;e.hasOwnProperty("_managedDisposables")||(e._managedDisposables=null!=(i=null==(r=e._managedDisposables)?void 0:r.slice())?i:[]);e._managedDisposables.unshift(t)}}class Ge extends Re{constructor(e){super(),this._material=e.material,this._techniqueRep=e.techniqueRep,this._output=e.output}get technique(){return this._technique}getPipelineState(e,t){return this.technique.pipeline}ensureResources(e){return 2}ensureParameters(e){}}const Ne=E();function qe(e,t,i,r,s,n,a){if(!D(t))if(e.boundingInfo){I(0===e.primitiveType);const t=i.tolerance;Ye(e.boundingInfo,r,s,t,n,a)}else{const t=e.indices.get("position"),i=e.vertexAttributes.get("position");Xe(r,s,0,t.length/3,t,i,void 0,n,a)}}const We=n();function Ye(e,t,s,n,a,o){if(i(e))return;const c=et(t,s,We);if(H(Ne,e.getBBMin()),U(Ne,e.getBBMax()),r(a)&&a.applyToAabb(Ne),tt(Ne,t,c,n)){const{primitiveIndices:i,indices:r,position:c}=e,l=i?i.length:r.length/3;if(l>ut){const i=e.getChildren();if(void 0!==i){for(let e=0;e<8;++e)void 0!==i[e]&&Ye(i[e],t,s,n,a,o);return}}Xe(t,s,0,l,r,c,i,a,o)}}const Ke=n();function Xe(e,t,i,s,n,a,o,c,l){if(o)return function(e,t,i,s,n,a,o,c,l){const u=a.data,d=a.stride||a.size,f=e[0],h=e[1],m=e[2],p=t[0],g=t[1],v=t[2],_=p-f,x=g-h,b=v-m;for(let e=i;e<s;++e){const t=o[e];let i=3*t,s=d*n[i++],a=u[s++],p=u[s++],g=u[s];s=d*n[i++];let v=u[s++],P=u[s++],y=u[s];s=d*n[i];let F=u[s++],S=u[s++],T=u[s];r(c)&&([a,p,g]=c.applyToVertex(a,p,g,e),[v,P,y]=c.applyToVertex(v,P,y,e),[F,S,T]=c.applyToVertex(F,S,T,e));const M=v-a,A=P-p,w=y-g,I=F-a,O=S-p,D=T-g,B=x*D-O*b,C=b*I-D*_,L=_*O-I*x,z=M*B+A*C+w*L;if(Math.abs(z)<=Number.EPSILON)continue;const E=f-a,H=h-p,U=m-g,$=E*B+H*C+U*L;if(z>0){if($<0||$>z)continue}else if($>0||$<z)continue;const k=H*w-A*U,V=U*M-w*E,R=E*A-M*H,j=_*k+x*V+b*R;if(z>0){if(j<0||$+j>z)continue}else if(j>0||$+j<z)continue;const G=(I*k+O*V+D*R)/z;if(G>=0){l(G,Qe(M,A,w,I,O,D,Ke),t)}}}(e,t,i,s,n,a,o,c,l);const u=a.data,d=a.stride||a.size,f=e[0],h=e[1],m=e[2],p=t[0]-f,g=t[1]-h,v=t[2]-m;for(let e=i,t=3*i;e<s;++e){let i=d*n[t++],s=u[i++],a=u[i++],o=u[i];i=d*n[t++];let _=u[i++],x=u[i++],b=u[i];i=d*n[t++];let P=u[i++],y=u[i++],F=u[i];r(c)&&([s,a,o]=c.applyToVertex(s,a,o,e),[_,x,b]=c.applyToVertex(_,x,b,e),[P,y,F]=c.applyToVertex(P,y,F,e));const S=_-s,T=x-a,M=b-o,A=P-s,w=y-a,I=F-o,O=g*I-w*v,D=v*A-I*p,B=p*w-A*g,C=S*O+T*D+M*B;if(Math.abs(C)<=Number.EPSILON)continue;const L=f-s,z=h-a,E=m-o,H=L*O+z*D+E*B;if(C>0){if(H<0||H>C)continue}else if(H>0||H<C)continue;const U=z*M-T*E,$=E*S-M*L,k=L*T-S*z,V=p*U+g*$+v*k;if(C>0){if(V<0||H+V>C)continue}else if(V>0||H+V<C)continue;const R=(A*U+w*$+I*k)/C;if(R>=0){l(R,Qe(S,T,M,A,w,I,Ke),e)}}}const Ze=n(),Je=n();function Qe(e,t,i,r,s,n,a){return h(Ze,e,t,i),h(Je,r,s,n),m(a,Ze,Je),p(a,a),a}function et(e,t,i){return h(i,1/(t[0]-e[0]),1/(t[1]-e[1]),1/(t[2]-e[2]))}function tt(e,t,i,r){return it(e,t,i,r,1/0)}function it(e,t,i,r,s){const n=(e[0]-r-t[0])*i[0],a=(e[3]+r-t[0])*i[0];let o=Math.min(n,a),c=Math.max(n,a);const l=(e[1]-r-t[1])*i[1],u=(e[4]+r-t[1])*i[1];if(c=Math.min(c,Math.max(l,u)),c<0)return!1;if(o=Math.max(o,Math.min(l,u)),o>c)return!1;const d=(e[2]-r-t[2])*i[2],f=(e[5]+r-t[2])*i[2];return c=Math.min(c,Math.max(d,f)),!(c<0)&&(o=Math.max(o,Math.min(d,f)),!(o>c)&&o<s)}function rt(e,t,i,r,s){let n=(i.screenLength||0)*e.pixelRatio;s&&(n=function(e,t,i,r){return Ce(e,De(t,i,r))}(n,r,t,s));const a=n*Math.tan(.5*e.fovY)/(.5*e.fullHeight);return f(a*t,i.minWorldLength||0,null!=i.maxWorldLength?i.maxWorldLength:1/0)}function st(e,t,i){if(!e)return;const r=e.parameters,s=e.paddingPixelsOverride;t.setUniform4f(i,r.divisor,r.offset,r.minPixelSize,s)}function nt(e,t){const i=t?nt(t):{};for(const t in e){let r=e[t];r&&r.forEach&&(r=ct(r)),null==r&&t in i||(i[t]=r)}return i}function at(e,t){let i=!1;for(const r in t){const s=t[r];void 0!==s&&(i=!0,Array.isArray(s)?e[r]=s.slice():e[r]=s)}return i}function ot(e,t,i,r,s){if(!t.options.selectionMode)return;const n=e.vertexAttributes.get("position").data,a=e.vertexAttributes.get("size"),o=a&&a.data[0],c=i[0],l=i[1],u=((o+r)/2+4)*e.screenToWorldRatio;let d=Number.MAX_VALUE;for(let e=0;e<n.length-5;e+=3){const t=n[e],i=n[e+1],r=c-t,s=l-i,a=n[e+3]-t,o=n[e+4]-i,u=f((a*r+o*s)/(a*a+o*o),0,1),h=a*u-r,m=o*u-s,p=h*h+m*m;p<d&&(d=p)}d<u*u&&s()}function ct(e){const t=[];return e.forEach((e=>t.push(e))),t}const lt={multiply:1,ignore:2,replace:3,tint:4},ut=1e3;class dt extends O{constructor(e,t){super(),this.type=3,this.supportsEdges=!1,this._visible=!0,this._renderPriority=0,this._insertOrder=0,this._vertexAttributeLocations=ce,this._params=nt(e,t),this.validateParameterValues(this._params)}dispose(){}get params(){return this._params}update(e){return!1}setParameterValues(e){at(this._params,e)&&(this.validateParameterValues(this._params),this.parametersChanged())}validateParameterValues(e){}get visible(){return this._visible}set visible(e){e!==this._visible&&(this._visible=e,this.parametersChanged())}isVisibleInPass(e){return!0}get renderOccluded(){return this.params.renderOccluded}get renderPriority(){return this._renderPriority}set renderPriority(e){e!==this._renderPriority&&(this._renderPriority=e,this.parametersChanged())}get insertOrder(){return this._insertOrder}set insertOrder(e){e!==this._insertOrder&&(this._insertOrder=e,this.parametersChanged())}get vertexAttributeLocations(){return this._vertexAttributeLocations}isVisible(){return this._visible}parametersChanged(){r(this.materialRepository)&&this.materialRepository.materialChanged(this)}}function ft(e,t){return e.isVisible()&&e.isVisibleInPass(t.pass)&&0!=(e.renderOccluded&t.renderOccludedMask)}const ht={renderOccluded:1};function mt(e,t,i,r){const s=i.typedBuffer,n=i.typedBufferStride,a=e.length;r*=n;for(let i=0;i<a;++i){const a=2*e[i];s[r]=t[a],s[r+1]=t[a+1],r+=n}}function pt(e,t,i,r,s){const n=i.typedBuffer,a=i.typedBufferStride,o=e.length;if(r*=a,null==s||1===s)for(let i=0;i<o;++i){const s=3*e[i];n[r]=t[s],n[r+1]=t[s+1],n[r+2]=t[s+2],r+=a}else for(let i=0;i<o;++i){const o=3*e[i];for(let e=0;e<s;++e)n[r]=t[o],n[r+1]=t[o+1],n[r+2]=t[o+2],r+=a}}function gt(e,t,i,r,s=1){const n=i.typedBuffer,a=i.typedBufferStride,o=e.length;if(r*=a,1===s)for(let i=0;i<o;++i){const s=4*e[i];n[r]=t[s],n[r+1]=t[s+1],n[r+2]=t[s+2],n[r+3]=t[s+3],r+=a}else for(let i=0;i<o;++i){const o=4*e[i];for(let e=0;e<s;++e)n[r]=t[o],n[r+1]=t[o+1],n[r+2]=t[o+2],n[r+3]=t[o+3],r+=a}}function vt(e,t,i,r,s,n=1){if(!i)return void pt(e,t,r,s,n);const a=r.typedBuffer,o=r.typedBufferStride,c=e.length,l=i[0],u=i[1],d=i[2],f=i[4],h=i[5],m=i[6],p=i[8],g=i[9],v=i[10],_=i[12],x=i[13],b=i[14];if(s*=o,1===n)for(let i=0;i<c;++i){const r=3*e[i],n=t[r],c=t[r+1],P=t[r+2];a[s]=l*n+f*c+p*P+_,a[s+1]=u*n+h*c+g*P+x,a[s+2]=d*n+m*c+v*P+b,s+=o}else for(let i=0;i<c;++i){const r=3*e[i],c=t[r],P=t[r+1],y=t[r+2],F=l*c+f*P+p*y+_,S=u*c+h*P+g*y+x,T=d*c+m*P+v*y+b;for(let e=0;e<n;++e)a[s]=F,a[s+1]=S,a[s+2]=T,s+=o}}function _t(e,t,i,r,s,n=1){if(!i)return void pt(e,t,r,s,n);const a=i,o=r.typedBuffer,c=r.typedBufferStride,l=e.length,u=a[0],d=a[1],f=a[2],h=a[4],m=a[5],p=a[6],g=a[8],v=a[9],_=a[10],x=!A(a),b=1e-6,P=.999999;if(s*=c,1===n)for(let i=0;i<l;++i){const r=3*e[i],n=t[r],a=t[r+1],l=t[r+2];let y=u*n+h*a+g*l,F=d*n+m*a+v*l,S=f*n+p*a+_*l;if(x){const e=y*y+F*F+S*S;if(e<P&&e>b){const t=1/Math.sqrt(e);y*=t,F*=t,S*=t}}o[s+0]=y,o[s+1]=F,o[s+2]=S,s+=c}else for(let i=0;i<l;++i){const r=3*e[i],a=t[r],l=t[r+1],y=t[r+2];let F=u*a+h*l+g*y,S=d*a+m*l+v*y,T=f*a+p*l+_*y;if(x){const e=F*F+S*S+T*T;if(e<P&&e>b){const t=1/Math.sqrt(e);F*=t,S*=t,T*=t}}for(let e=0;e<n;++e)o[s+0]=F,o[s+1]=S,o[s+2]=T,s+=c}}function xt(e,t,i,r,s,n=1){if(!i)return void gt(e,t,r,s,n);const a=i,o=r.typedBuffer,c=r.typedBufferStride,l=e.length,u=a[0],d=a[1],f=a[2],h=a[4],m=a[5],p=a[6],g=a[8],v=a[9],_=a[10],x=!A(a),b=1e-6,P=.999999;if(s*=c,1===n)for(let i=0;i<l;++i){const r=4*e[i],n=t[r],a=t[r+1],l=t[r+2],y=t[r+3];let F=u*n+h*a+g*l,S=d*n+m*a+v*l,T=f*n+p*a+_*l;if(x){const e=F*F+S*S+T*T;if(e<P&&e>b){const t=1/Math.sqrt(e);F*=t,S*=t,T*=t}}o[s+0]=F,o[s+1]=S,o[s+2]=T,o[s+3]=y,s+=c}else for(let i=0;i<l;++i){const r=4*e[i],a=t[r],l=t[r+1],y=t[r+2],F=t[r+3];let S=u*a+h*l+g*y,T=d*a+m*l+v*y,M=f*a+p*l+_*y;if(x){const e=S*S+T*T+M*M;if(e<P&&e>b){const t=1/Math.sqrt(e);S*=t,T*=t,M*=t}}for(let e=0;e<n;++e)o[s+0]=S,o[s+1]=T,o[s+2]=M,o[s+3]=F,s+=c}}function bt(e,t,i,r,s,n=1){const a=r.typedBuffer,o=r.typedBufferStride,c=e.length;if(s*=o,1===n){if(4===i)for(let i=0;i<c;++i){const r=4*e[i];a[s]=t[r],a[s+1]=t[r+1],a[s+2]=t[r+2],a[s+3]=t[r+3],s+=o}else if(3===i)for(let i=0;i<c;++i){const r=3*e[i];a[s]=t[r],a[s+1]=t[r+1],a[s+2]=t[r+2],a[s+3]=255,s+=o}}else if(4===i)for(let i=0;i<c;++i){const r=4*e[i];for(let e=0;e<n;++e)a[s]=t[r],a[s+1]=t[r+1],a[s+2]=t[r+2],a[s+3]=t[r+3],s+=o}else if(3===i)for(let i=0;i<c;++i){const r=3*e[i];for(let e=0;e<n;++e)a[s]=t[r],a[s+1]=t[r+1],a[s+2]=t[r+2],a[s+3]=255,s+=o}}function Pt(e,t,i,r,s,n){for(const a of t.fieldNames){const t=e.vertexAttributes.get(a),o=e.indices.get(a);if(t&&o)switch(a){case"position":{I(3===t.size);const e=s.getField(a,R);e&&vt(o,t.data,i,e,n);break}case"normal":{I(3===t.size);const e=s.getField(a,R);e&&_t(o,t.data,r,e,n);break}case"uv0":{I(2===t.size);const e=s.getField(a,V);e&&mt(o,t.data,e,n);break}case"color":{I(3===t.size||4===t.size);const e=s.getField(a,k);e&&bt(o,t.data,t.size,e,n);break}case"symbolColor":{I(3===t.size||4===t.size);const e=s.getField(a,k);e&&bt(o,t.data,t.size,e,n);break}case"tangent":{I(4===t.size);const e=s.getField(a,$);e&&xt(o,t.data,r,e,n);break}}}}function yt(e,t){if(t.slicePlaneEnabled){e.extensions.add("GL_OES_standard_derivatives"),t.sliceEnabledForVertexPrograms&&(e.vertex.uniforms.add("slicePlaneOrigin","vec3"),e.vertex.uniforms.add("slicePlaneBasis1","vec3"),e.vertex.uniforms.add("slicePlaneBasis2","vec3")),e.fragment.uniforms.add("slicePlaneOrigin","vec3"),e.fragment.uniforms.add("slicePlaneBasis1","vec3"),e.fragment.uniforms.add("slicePlaneBasis2","vec3");const i=G`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`,r=G`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
if (sliceByFactors(factors)) {
return color;
}
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`,s=t.sliceHighlightDisabled?G`#define highlightSlice(_color_, _pos_) (_color_)`:G`
        ${r}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      `;t.sliceEnabledForVertexPrograms&&e.vertex.code.add(i),e.fragment.code.add(i),e.fragment.code.add(s)}else{const i=G`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;t.sliceEnabledForVertexPrograms&&e.vertex.code.add(i),e.fragment.code.add(i)}}function Ft(e,t,i){St(e,t,i.slicePlane,i.origin)}function St(e,t,i,s){t.slicePlaneEnabled&&(r(i)?(s?(g(Tt,i.origin,s),e.setUniform3fv("slicePlaneOrigin",Tt)):e.setUniform3fv("slicePlaneOrigin",i.origin),e.setUniform3fv("slicePlaneBasis1",i.basis1),e.setUniform3fv("slicePlaneBasis2",i.basis2)):(e.setUniform3fv("slicePlaneBasis1",v),e.setUniform3fv("slicePlaneBasis2",v),e.setUniform3fv("slicePlaneOrigin",v)))}const Tt=n();function Mt(e){e.code.add(G`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}
const vec4 RGBA_2_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, RGBA_2_FLOAT_FACTORS);
}`)}function At(e){e.include(Mt),e.code.add(G`float linearDepthFromFloat(float depth, vec2 nearFar) {
return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);
}
float linearDepthFromTexture(sampler2D depthTex, vec2 uv, vec2 nearFar) {
return linearDepthFromFloat(rgba2float(texture2D(depthTex, uv)), nearFar);
}`)}const wt=j(1,1,0,1),It=j(1,0,1,1);function Ot(e){e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("highlightViewportPixelSz","vec4"),e.fragment.constants.add("occludedHighlightFlag","vec4",wt).add("unoccludedHighlightFlag","vec4",It),e.fragment.code.add(G`void outputHighlight() {
vec4 fragCoord = gl_FragCoord;
float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;
if (fragCoord.z > sceneDepth + 5e-7) {
gl_FragColor = occludedHighlightFlag;
}
else {
gl_FragColor = unoccludedHighlightFlag;
}
}`)}function Dt(e,t){e.bindTexture(t.highlightDepthTexture,"depthTex"),e.setUniform4f("highlightViewportPixelSz",0,0,t.inverseViewport[0],t.inverseViewport[1])}const Bt=.1,Ct=.001;function Lt(e,t){const i=e.fragment;switch(t.alphaDiscardMode){case 0:i.code.add(G`
        #define discardOrAdjustAlpha(color) { if (color.a < ${G.float(.001)}) { discard; } }
      `);break;case 1:i.code.add(G`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);break;case 2:i.uniforms.add("textureAlphaCutoff","float"),i.code.add(G`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);break;case 3:e.fragment.uniforms.add("textureAlphaCutoff","float"),e.fragment.code.add(G`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`)}}function zt(e,t){e.fragment.uniforms.add("terrainDepthTexture","sampler2D"),e.fragment.uniforms.add("cameraNearFar","vec2"),e.fragment.uniforms.add("inverseViewport","vec2"),e.fragment.code.add(G`
    // Compare the linearized depths of fragment and terrain. Discard fragments on the wrong side of the terrain.
    void terrainDepthTest(vec4 fragCoord, float fragmentDepth){

      float terrainDepth = linearDepthFromTexture(terrainDepthTexture, fragCoord.xy * inverseViewport, cameraNearFar);
      if(fragmentDepth ${t.cullAboveGround?">":"<="} terrainDepth){
        discard;
      }
    }
  `)}function Et(e,t){t.multipassTerrainEnabled&&t.terrainLinearDepthTexture&&e.bindTexture(t.terrainLinearDepthTexture,"terrainDepthTexture")}const Ht=F(770,1,771,771),Ut=S(1,1),$t=S(0,771);function kt(e){return 2===e?null:1===e?$t:Ut}function Vt(e){return 2===e?T:null}const Rt=5e5,jt={factor:-1,units:-2};function Gt(e){return e?jt:null}function Nt(e){return 3===e||2===e?513:515}const qt={func:513},Wt={func:519},Yt={mask:255},Kt={mask:0},Xt=e=>({function:{func:517,ref:e,mask:e},operation:{fail:7680,zFail:7680,zPass:7680}}),Zt=e=>({function:{func:519,ref:e,mask:e},operation:{fail:7680,zFail:7680,zPass:7681}}),Jt={function:{func:519,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:0}},Qt={function:{func:519,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7681}},ei={function:{func:514,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7680}},ti={function:{func:517,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7680}};function ii(e,t){e.fragment.include(Mt),3===t.output?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(G`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 2.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
float result = depth + SLOPE_SCALE * m + BIAS;
return clamp(result, .0, .999999);
}
void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));
}`)):1===t.output&&e.fragment.code.add(G`void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_linearDepth);
}`)}function ri(e,t){t.attributeColor?(e.attributes.add("color","vec4"),e.varyings.add("vColor","vec4"),e.vertex.code.add(G`void forwardVertexColor() { vColor = color; }`),e.vertex.code.add(G`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)):e.vertex.code.add(G`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}export{Ve as $,Re as A,zt as B,Pe as C,ce as D,Dt as E,Ht as F,kt as G,Nt as H,Yt as I,Zt as J,Jt as K,jt as L,Bt as M,ye as N,ii as O,le as P,Mt as Q,se as R,Y as S,N as T,It as U,ri as V,Te as W,Et as X,ve as Y,ft as Z,we as _,ae as a,xe as a0,me as a1,ue as a2,Ft as a3,Vt as a4,Gt as a5,Ge as a6,pe as a7,dt as a8,ht as a9,vt as aa,_t as ab,gt as ac,lt as ad,fe as ae,Pt as af,Qt as ag,Rt as ah,qe as ai,bt as aj,he as ak,rt as al,Ce as am,Le as an,Wt as ao,ti as ap,Kt as aq,ei as ar,qt as as,ot as at,nt as au,at as av,ne as b,de as c,Se as d,ze as e,Ie as f,G as g,Oe as h,Qe as i,Fe as j,Ae as k,Me as l,yt as m,Ot as n,it as o,oe as p,Xe as q,Xt as r,st as s,St as t,je as u,et as v,tt as w,Lt as x,Ct as y,At as z};
