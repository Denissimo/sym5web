/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../geometry.js";import t from"../Graphic.js";import r from"../core/Collection.js";import s from"../core/Error.js";import{i,b as o,h as n}from"../core/lang.js";import{L as a}from"./Loadable.js";import{L as l}from"./Logger.js";import{a as u}from"./Promise.js";import{open as p}from"../core/workers/workers.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import{e as d}from"./ensureType.js";import{s as y}from"./shared.js";import{subclass as h}from"../core/accessorSupport/decorators/subclass.js";import{a as m}from"./queryZScale.js";import{u as f}from"./zscale.js";import g from"../rest/support/FeatureSet.js";import _ from"../geometry/Extent.js";import S from"../geometry/Polygon.js";import{t as b}from"./typeUtils.js";import{a as j}from"./JSONSupport.js";let F=0;const T=l.getLogger("esri.layers.graphics.sources.MemorySource");let O=class extends(a.LoadableMixin(u(r))){constructor(e){super(e),this._idToClientGraphic=null,this.type="memory"}load(e){const t=i(e)?e.signal:null;return this.addResolvingPromise(this._startWorker(t)),Promise.resolve(this)}destroy(){var e;null==(e=this._connection)||e.close(),this._connection=null}get workerGeometryType(){var e;const t=null==(e=this.layer)?void 0:e.geometryType;return t?this._geometryTypeRequiresClientGraphicMapping(t)?"polygon":t:null}applyEdits(e){return this.load().then((()=>this._applyEdits(e)))}openPorts(){return this.load().then((()=>this._connection.openPorts()))}async queryFeatures(e,t={}){await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);m(e,this.layer.spatialReference,r);const s=g.fromJSON(r);if(!this._requiresClientGraphicMapping())return s;const i=this.layer.objectIdField;for(const e of s.features){const t=e.attributes[i],r=this._idToClientGraphic.get(t);r&&(e.geometry=r.geometry)}return s.geometryType=this.layer.geometryType,s}async queryFeaturesJSON(e,t={}){if(this._requiresClientGraphicMapping())throw new s("query-features-json:unsupported","Cannot query in JSON format for client only geometry types (mesh and extent)");await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);return m(e,this.layer.spatialReference,r),r}queryFeatureCount(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryFeatureCount",e?e.toJSON():null,t)))}queryObjectIds(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryObjectIds",e?e.toJSON():null,t)))}queryExtent(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryExtent",e?e.toJSON():null,t))).then((e=>({count:e.count,extent:_.fromJSON(e.extent)})))}querySnapping(e,t={}){return this.load(t).then((()=>this._connection.invoke("querySnapping",e,t)))}async _applyEdits(e){if(!this._connection)throw new s("feature-layer-source:edit-failure","Memory source not loaded");const t=this.layer.objectIdField;let r=null;const i=[],o=[];await Promise.all([this._prepareClientMapping(e.addFeatures,null),this._prepareClientMapping(e.updateFeatures,null)]);const n=e=>"objectId"in e&&null!=e.objectId?e.objectId:"attributes"in e&&null!=e.attributes[t]?e.attributes[t]:null;if(e.addFeatures&&(r=this._prepareAddFeatures(e.addFeatures)),e.deleteFeatures)for(const t of e.deleteFeatures){const e=n(t);null!=e&&i.push(e)}const a=e.updateFeatures&&this._idToClientGraphic?new Map:null;if(e.updateFeatures)for(const t of e.updateFeatures)if(o.push(this._serializeFeature(t)),a){const e=n(t);null!=e&&a.set(e,t)}f(r?r.features:null,o,this.layer.spatialReference);const{fullExtent:l,featureEditResults:u}=await this._connection.invoke("applyEdits",{adds:r?r.features:[],updates:o,deletes:i});return this.fullExtent=l,r&&r.finish(u.uidToObjectId),this._updateClientGraphicIds(a,u),this._createEditsResult(u)}async _prepareClientMapping(e,t){if("mesh"!==this.layerOrSourceGeometryType||o(e))return;const r=[];for(const{geometry:s}of e)!i(s)||"mesh"!==s.type||s.hasExtent||s.loaded||r.push(s.load({signal:t}));r.length&&await Promise.all(r)}_updateClientGraphicIds(e,t){if(this._idToClientGraphic){if(e)for(const r of t.updateResults){if(!r.success)continue;const t=e.get(r.objectId);null!=t&&this._addIdToClientGraphic(t)}for(const e of t.deleteResults)e.success&&this._idToClientGraphic.delete(e.objectId)}}_createEditsResult(e){return{addFeatureResults:e.addResults?e.addResults.map(this._createFeatureEditResult,this):[],updateFeatureResults:e.updateResults?e.updateResults.map(this._createFeatureEditResult,this):[],deleteFeatureResults:e.deleteResults?e.deleteResults.map(this._createFeatureEditResult,this):[],addAttachmentResults:[],updateAttachmentResults:[],deleteAttachmentResults:[]}}_createFeatureEditResult(e){const t=!0===e.success?null:e.error||{code:void 0,description:void 0};return{objectId:e.objectId,globalId:e.globalId,error:t?new s("feature-layer-source:edit-failure",t.description,{code:t.code}):null}}_prepareAddFeatures(e){const t=new Map,r=new Array(e.length);let s=null;for(let o=0;o<e.length;o++){const n=e[o],a=this._serializeFeature(n);!s&&i(n.geometry)&&(s=n.geometry.type),r[o]=a,t.set(`${a.uid}`,n)}const o=this;return{features:r,inferredGeometryType:s,finish(e){const r=o.sourceJSON.objectIdField;for(const s in e){const i=e[s],n=t.get(s);n&&(n.attributes||(n.attributes={}),-1===i?delete n.attributes[r]:n.attributes[r]=i,o._addIdToClientGraphic(n))}}}}_addIdToClientGraphic(e){if(!this._idToClientGraphic)return;const t=this.sourceJSON.objectIdField,r=e.attributes&&e.attributes[t];null!=r&&this._idToClientGraphic.set(r,e)}get layerOrSourceGeometryType(){var e,t,r;return null!=(e=null==(t=this.layer)?void 0:t.geometryType)?e:null==(r=this.sourceJSON)?void 0:r.geometryType}_requiresClientGraphicMapping(){return this._geometryTypeRequiresClientGraphicMapping(this.layerOrSourceGeometryType)}_geometryRequiresClientGraphicMapping(e){return this._geometryTypeRequiresClientGraphicMapping(e.type)}_geometryTypeRequiresClientGraphicMapping(e){return"mesh"===e||"multipatch"===e||"extent"===e}_serializeFeature(e){const{attributes:t}=e,r=this._geometryForSerialization(e),s=(F++).toString();return r?{uid:s,geometry:r.toJSON(),attributes:t}:{uid:s,attributes:t}}_geometryForSerialization(e){const{geometry:t}=e;if(o(t))return null;if(this._geometryRequiresClientGraphicMapping(t)){return t.extent?S.fromExtent(t.extent):null}return t}async _startWorker(e){this._connection=await p("MemorySourceWorker",{strategy:n("feature-layers-workers")?"dedicated":"local",signal:e});const{fields:t,spatialReference:r,objectIdField:s,hasM:i,hasZ:o,timeInfo:a}=this.layer,l="defaults"===this.layer.originOf("spatialReference");await this._prepareClientMapping(this.items,e);const u=this._prepareAddFeatures(this.items);this.on("before-changes",(e=>{T.error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"),e.preventDefault()}));const c={features:u.features,fields:t&&t.map((e=>e.toJSON())),geometryType:b.toJSON(this.workerGeometryType),hasM:"mesh"!==this.layerOrSourceGeometryType&&i,hasZ:"mesh"===this.layerOrSourceGeometryType||o,objectIdField:s,spatialReference:l?null:r&&r.toJSON(),timeInfo:a?a.toJSON():null},d=await this._connection.invoke("load",c,{signal:e});for(const e of d.warnings)T.warn(e.message,{layer:this.layer,warning:e});d.featureErrors.length&&T.warn(`Encountered ${d.featureErrors.length} validation errors while loading features`,d.featureErrors);const y=d.layerDefinition;this._geometryTypeRequiresClientGraphicMapping(u.inferredGeometryType)&&(y.geometryType=b.toJSON(u.inferredGeometryType)),this.sourceJSON=y,this._requiresClientGraphicMapping()&&(this._idToClientGraphic=new Map),u.finish(d.assignedObjectIds)}};e([y({Type:t,ensureType:d(t)})],O.prototype,"itemType",void 0),e([c()],O.prototype,"type",void 0),e([c({constructOnly:!0})],O.prototype,"layer",void 0),e([c({readOnly:!0})],O.prototype,"workerGeometryType",null),e([c()],O.prototype,"sourceJSON",void 0),O=e([h("esri.layers.graphics.sources.MemorySource")],O);var G,R=O;let w=G=class extends j{constructor(e){super(e)}clone(){const{name:e,fields:t,isAscending:r,isUnique:s,description:i}=this;return new G({name:e,fields:t,isAscending:r,isUnique:s,description:i})}};e([c({constructOnly:!0})],w.prototype,"name",void 0),e([c({constructOnly:!0})],w.prototype,"fields",void 0),e([c({constructOnly:!0})],w.prototype,"isAscending",void 0),e([c({constructOnly:!0})],w.prototype,"isUnique",void 0),e([c({constructOnly:!0})],w.prototype,"description",void 0),w=G=e([h("esri.layers.support.FeatureIndex")],w);export{w as F,R as M};
