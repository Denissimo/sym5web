/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{i as t}from"../core/lang.js";import{n as s}from"./mat3.js";import{c as i,d as r}from"./quatf64.js";import{c as e,e as o,d as a,m as n}from"./mat4.js";import{c as h}from"./mat4f64.js";import{c as f}from"./quat.js";import{b as l,C as m,g as b,s as c}from"./mathUtils.js";import{c as p}from"./vec3f32.js";import{a as u}from"./vec4f64.js";import{c as v}from"./sphere.js";class g{constructor(){this._transform=h(),this._transformInverse=new z({value:this._transform},e,h),this._transformInverseTranspose=new z(this._transformInverse,o,h),this._transformTranspose=new z({value:this._transform},o,h),this._transformInverseRotation=new z({value:this._transform},s,i)}invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(t){a(this._transform,t)}multiplyTransform(t){n(this._transform,this._transform,t)}set(t){a(this._transform,t),this.invalidateLazyTransforms()}setAndInvalidateLazyTransforms(t,s){this.setTransformMatrix(t),this.multiplyTransform(s),this.invalidateLazyTransforms()}}class z{constructor(t,s,i){this.original=t,this.update=s,this.dirty=!0,this.transform=i()}invalidate(){this.dirty=!0}get value(){return this.dirty&&(this.update(this.transform,this.original.value),this.dirty=!1),this.transform}}const S=new class{constructor(t=0){this.offset=t,this.sphere=v(),this.tmpVertex=l()}applyToVertex(t,s,i){const r=this.objectTransform.transform;let e=r[0]*t+r[4]*s+r[8]*i+r[12],o=r[1]*t+r[5]*s+r[9]*i+r[13],a=r[2]*t+r[6]*s+r[10]*i+r[14];const n=this.offset/Math.sqrt(e*e+o*o+a*a);e+=e*n,o+=o*n,a+=a*n;const h=this.objectTransform.inverse;return this.tmpVertex[0]=h[0]*e+h[4]*o+h[8]*a+h[12],this.tmpVertex[1]=h[1]*e+h[5]*o+h[9]*a+h[13],this.tmpVertex[2]=h[2]*e+h[6]*o+h[10]*a+h[14],this.tmpVertex}applyToMinMax(t,s){const i=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*i,t[1]+=t[1]*i,t[2]+=t[2]*i;const r=this.offset/Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);s[0]+=s[0]*r,s[1]+=s[1]*r,s[2]+=s[2]*r}applyToAabb(t){const s=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*s,t[1]+=t[1]*s,t[2]+=t[2]*s;const i=this.offset/Math.sqrt(t[3]*t[3]+t[4]*t[4]+t[5]*t[5]);return t[3]+=t[3]*i,t[4]+=t[4]*i,t[5]+=t[5]*i,t}applyToBoundingSphere(t){const s=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),i=this.offset/s;return this.sphere[0]=t[0]+t[0]*i,this.sphere[1]=t[1]+t[1]*i,this.sphere[2]=t[2]+t[2]*i,this.sphere[3]=t[3]+t[3]*this.offset/s,this.sphere}};function T(s){return t(s)?(S.offset=s,S):null}const q=new class{constructor(t=0){this.offset=t,this.componentLocalOriginLength=0,this.tmpVertex=l(),this.mbs=u(),this.obb={center:l(),halfSize:p(),quaternion:null}}set localOrigin(t){this.componentLocalOriginLength=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}applyToVertex(t,s,i){const r=t,e=s,o=i+this.componentLocalOriginLength,a=this.offset/Math.sqrt(r*r+e*e+o*o);return this.tmpVertex[0]=t+r*a,this.tmpVertex[1]=s+e*a,this.tmpVertex[2]=i+o*a,this.tmpVertex}applyToAabb(t){const s=t[0],i=t[1],r=t[2]+this.componentLocalOriginLength,e=t[3],o=t[4],a=t[5]+this.componentLocalOriginLength,n=this.offset/Math.sqrt(s*s+i*i+r*r);t[0]+=s*n,t[1]+=i*n,t[2]+=r*n;const h=this.offset/Math.sqrt(e*e+o*o+a*a);return t[3]+=e*h,t[4]+=o*h,t[5]+=a*h,t}applyToMbs(t){const s=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),i=this.offset/s;return this.mbs[0]=t[0]+t[0]*i,this.mbs[1]=t[1]+t[1]*i,this.mbs[2]=t[2]+t[2]*i,this.mbs[3]=t[3]+t[3]*this.offset/s,this.mbs}applyToObb(t){const s=t.center,i=this.offset/Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);this.obb.center[0]=s[0]+s[0]*i,this.obb.center[1]=s[1]+s[1]*i,this.obb.center[2]=s[2]+s[2]*i,m(this.obb.halfSize,t.halfSize,t.quaternion),b(this.obb.halfSize,this.obb.halfSize,t.center);const r=this.offset/Math.sqrt(this.obb.halfSize[0]*this.obb.halfSize[0]+this.obb.halfSize[1]*this.obb.halfSize[1]+this.obb.halfSize[2]*this.obb.halfSize[2]);return this.obb.halfSize[0]+=this.obb.halfSize[0]*r,this.obb.halfSize[1]+=this.obb.halfSize[1]*r,this.obb.halfSize[2]+=this.obb.halfSize[2]*r,c(this.obb.halfSize,this.obb.halfSize,t.center),f(d,t.quaternion),m(this.obb.halfSize,this.obb.halfSize,d),this.obb.halfSize[0]*=this.obb.halfSize[0]<0?-1:1,this.obb.halfSize[1]*=this.obb.halfSize[1]<0?-1:1,this.obb.halfSize[2]*=this.obb.halfSize[2]<0?-1:1,this.obb.quaternion=t.quaternion,this.obb}};function x(s){return t(s)?(q.offset=s,q):null}const _=new class{constructor(t=0){this.offset=t,this.tmpVertex=l()}applyToVertex(t,s,i){const r=t+this.localOrigin[0],e=s+this.localOrigin[1],o=i+this.localOrigin[2],a=this.offset/Math.sqrt(r*r+e*e+o*o);return this.tmpVertex[0]=t+r*a,this.tmpVertex[1]=s+e*a,this.tmpVertex[2]=i+o*a,this.tmpVertex}applyToAabb(t){const s=t[0]+this.localOrigin[0],i=t[1]+this.localOrigin[1],r=t[2]+this.localOrigin[2],e=t[3]+this.localOrigin[0],o=t[4]+this.localOrigin[1],a=t[5]+this.localOrigin[2],n=this.offset/Math.sqrt(s*s+i*i+r*r);t[0]+=s*n,t[1]+=i*n,t[2]+=r*n;const h=this.offset/Math.sqrt(e*e+o*o+a*a);return t[3]+=e*h,t[4]+=o*h,t[5]+=a*h,t}};function M(s){return t(s)?(_.offset=s,_):null}const y="terrain",d=r();export{g as I,y as T,M as a,x as b,T as g};
