/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{revision as e,version as s,buildDate as t}from"../../kernel.js";import o from"../Error.js";import{onAbortOrThrow as r,createAbortError as n,createAbortController as i,isPromiseLike as a,isAbortError as c,o as l}from"../promiseUtils.js";import{h,i as u}from"../lang.js";import"../urlUtils.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/Logger.js";import"../../chunks/string.js";import"../../chunks/Message.js";const p={statsWorker:()=>import("../../chunks/statsWorker.js"),geometryEngineWorker:()=>import("../../chunks/geometryEngineWorker.js"),CSVSourceWorker:()=>import("../../chunks/CSVSourceWorker.js"),EdgeProcessingWorker:()=>import("../../chunks/EdgeProcessingWorker.js").then((function(e){return e.b})),ElevationSamplerWorker:()=>import("../../chunks/ElevationSamplerWorker.js"),FeatureServiceSnappingSourceWorker:()=>import("../../chunks/FeatureServiceSnappingSourceWorker.js"),GeoJSONSourceWorker:()=>import("../../chunks/GeoJSONSourceWorker.js"),LercWorker:()=>import("../../chunks/LercWorker.js"),MemorySourceWorker:()=>import("../../chunks/MemorySourceWorker.js"),PBFDecoderWorker:()=>import("../../chunks/PBFDecoderWorker.js"),Pipeline:()=>import("../../chunks/Pipeline.js"),PointCloudWorker:()=>import("../../chunks/PointCloudWorker.js"),RasterWorker:()=>import("../../chunks/RasterWorker.js"),SceneLayerWorker:()=>import("../../chunks/SceneLayerWorker.js"),WFSSourceWorker:()=>import("../../chunks/WFSSourceWorker.js"),WorkerTileHandler:()=>import("../../chunks/WorkerTileHandler.js")};var _;!function(e){e[e.HANDSHAKE=0]="HANDSHAKE",e[e.OPEN=1]="OPEN",e[e.OPENED=2]="OPENED",e[e.RESPONSE=3]="RESPONSE",e[e.INVOKE=4]="INVOKE",e[e.ABORT=5]="ABORT",e[e.CLOSE=6]="CLOSE",e[e.OPEN_PORT=7]="OPEN_PORT",e[e.ON=8]="ON"}(_||(_={}));let g=0;function d(){return g++}function m(e){return e?"string"==typeof e?JSON.stringify({name:"message",message:e}):e.toJSON?JSON.stringify(e):JSON.stringify({name:e.name,message:e.message,details:e.details||{stack:e.stack}}):null}function k(e,s,t,o){if(s.type===_.OPEN_PORT)return void e.postMessage(s,[s.port]);if(s.type!==_.INVOKE&&s.type!==_.RESPONSE)return void e.postMessage(s);let r;var n;(n=t)&&"object"==typeof n&&("result"in n||"transferList"in n)?(r=b(t.transferList),s.data=t.result):(r=b(o),s.data=t),r?e.postMessage(s,r):e.postMessage(s)}function f(e){if(!e)return null;const s=e.data;return s?"string"==typeof s?JSON.parse(s):s:null}function b(e){if(!e||!e.length)return null;if(h("esri-workers-arraybuffer-transfer"))return e;const s=e.filter((e=>{return!((s=e)instanceof ArrayBuffer||s&&s.constructor&&"ArrayBuffer"===s.constructor.name);var s}));return s.length?s:null}const{CLOSE:v,ABORT:O,INVOKE:S,RESPONSE:j,OPEN_PORT:E,ON:y}=_;class M{constructor(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this)}push(e){e.type===_.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))}clear(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null}_process(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0}}class N{constructor(e,s){this._port=e,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new M((e=>this._onInvokeMessage(e))),this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,this._schedule=s.schedule,this._port.addEventListener("message",this._onMessage),this._port.start()}static connect(e){const s=new MessageChannel;let t;t="function"==typeof e?new e:"default"in e&&"function"==typeof e.default?new e.default:e;const o=new N(s.port1,{channel:s,client:t});return"object"==typeof t&&"remoteClient"in t&&(t.remoteClient=o),N.clients.set(o,t),s.port2}static loadWorker(e){const s=p[e];return s?s():Promise.resolve(null)}close(){this._post({type:v}),this._close()}isBusy(){return this._outJobs.size>0}invoke(e,s,t){const i=t&&t.signal,a=t&&t.transferList;if(!this._port)return Promise.reject(new o("worker:port-closed",`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:s}));const c=d();return new Promise(((t,o)=>{const l=r(i,(()=>{var e;const s=this._outJobs.get(c);s&&(this._outJobs.delete(c),null==(e=s.abortHandle)||e.remove(),this._post({type:O,jobId:c}),o(n()))})),h={resolve:t,reject:o,abortHandle:l,debugInfo:e};this._outJobs.set(c,h),this._post({type:S,jobId:c,methodName:e,abortable:null!=i},s,a)}))}on(e,s){const t=new MessageChannel;function o(e){s(e.data)}return this._port.postMessage({type:_.ON,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",o),t.port1.start(),{remove(){t.port1.postMessage({type:_.CLOSE}),t.port1.close(),t.port1.removeEventListener("message",o)}}}openPort(){const e=new MessageChannel;return this._post({type:E,port:e.port2}),e.port1}_close(){this._channel&&(this._channel=null),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{var s;null==(s=e.abortHandle)||s.remove(),e.reject(n(`Worker closing, aborting job calling '${e.debugInfo}'`))})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=this._client=this._schedule=null}_onMessage(e){u(this._schedule)?this._schedule((()=>this._processMessage(e))):this._processMessage(e)}_processMessage(e){const s=f(e);if(s)switch(s.type){case j:this._onResponseMessage(s);break;case S:this._invokeQueue.push(s);break;case O:this._onAbortMessage(s);break;case v:this._onCloseMessage();break;case E:this._onOpenPortMessage(s);break;case y:this._onOnMessage(s)}}_onAbortMessage(e){const s=this._inJobs,t=e.jobId,o=s.get(t);this._invokeQueue.push(e),o&&(o.controller&&o.controller.abort(),s.delete(t))}_onCloseMessage(){const e=this._client;this._close(),e&&"destroy"in e&&N.clients.get(this)===e&&e.destroy(),N.clients.delete(this),e&&e.remoteClient&&(e.remoteClient=null)}_onInvokeMessage(e){const{methodName:s,jobId:t,data:o,abortable:r}=e,n=r?i():null,l=this._inJobs;let h,u=this._client,p=u[s];try{if(!p&&s&&-1!==s.indexOf(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)u=u[e[s]],p=u[e[s+1]]}if("function"!=typeof p)throw new TypeError(`${s} is not a function`);h=p.call(u,o,{client:this,signal:n?n.signal:null})}catch(e){return void this._post({type:j,jobId:t,error:m(e)})}a(h)?(l.set(t,{controller:n,promise:h}),h.then((e=>{l.has(t)&&(l.delete(t),this._post({type:j,jobId:t},e))}),(e=>{l.has(t)&&(l.delete(t),c(e)||this._post({type:j,jobId:t,error:m(e||{message:`Error encountered at method ${s}`})}))}))):this._post({type:j,jobId:t},h)}_onOpenPortMessage(e){new N(e.port,{client:this._client})}_onOnMessage(e){const{port:s}=e,t=this._client.on(e.eventType,(e=>{s.postMessage(e)})),o=l(e.port,"message",(e=>{f(e).type===_.CLOSE&&(o.remove(),t.remove(),s.close())}))}_onResponseMessage(e){var s;const{jobId:t,error:r,data:n}=e,i=this._outJobs;if(!i.has(t))return;const a=i.get(t);i.delete(t),null==(s=a.abortHandle)||s.remove(),r?a.reject(o.fromJSON(JSON.parse(r))):a.resolve(n)}_post(e,s,t){return k(this._port,e,s,t)}}N.kernelInfo={revision:e,version:s,buildDate:t},N.clients=new Map;export default N;export{_ as M,d as n,k as p,f as r,m as t};
