/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import{b as s,clone as e}from"../../core/lang.js";import i from"../../core/Error.js";import{a as r}from"../../chunks/JSONSupport.js";import{L as l}from"../../chunks/Logger.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import{cast as o}from"../../core/accessorSupport/decorators/cast.js";import{subclass as h}from"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Message.js";import"../../chunks/object.js";import"../../config.js";import"../../chunks/string.js";import"../../core/Accessor.js";import"../../chunks/deprecate.js";import"../../chunks/metadata.js";import"../../chunks/handleUtils.js";import"../../chunks/ArrayPool.js";import"../../chunks/arrayUtils.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/ensureType.js";import"../../chunks/write.js";var n;const p=l.getLogger("esri.layers.support.PixelBlock");let c=n=class extends r{constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.pixels=null,this.statistics=null}static createEmptyBand(t,s){return new(n.getPixelArrayConstructor(t))(s)}static getPixelArrayConstructor(t){let s;switch(t){case"u1":case"u2":case"u4":case"u8":s=Uint8Array;break;case"u16":s=Uint16Array;break;case"u32":s=Uint32Array;break;case"s8":s=Int8Array;break;case"s16":s=Int16Array;break;case"s32":s=Int32Array;break;case"u32":s=Uint32Array;break;case"f32":s=Float32Array;break;case"f64":s=Float64Array;break;case"c64":case"c128":case"unknown":s=Float32Array}return s}castPixelType(t){if(!t)return"f32";let s=t.toLowerCase();return["u1","u2","u4"].indexOf(s)>-1?s="u8":-1===["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].indexOf(s)&&(s="f32"),s}getPlaneCount(){return this.pixels&&this.pixels.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new i("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics||{minValue:null,maxValue:null})}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){this.statistics=this.pixels.map((t=>this._calculateBandStatistics(t,this.mask)));const t=this.mask;let s=0;if(t)for(let e=0;e<t.length;e++)t[e]&&s++;else s=this.width*this.height;this.validPixelCount=s}clamp(t){if(!t||"f64"===t||"f32"===t)return;let s;switch(t){case"u8":s=[0,255];break;case"u16":s=[0,65535];break;case"u32":s=[0,4294967295];break;case"s8":s=[-128,127];break;case"s16":s=[-32768,32767];break;case"s32":s=[-2147483648,2147483647];break;default:s=[-34e38,34e38]}const[e,i]=s,r=this.pixels,l=this.width*this.height,a=r.length;let o,h,p;const c=[];for(let s=0;s<a;s++){p=n.createEmptyBand(t,l),o=r[s];for(let t=0;t<l;t++)h=o[t],p[t]=h>i?i:h<e?e:h;c.push(p)}this.pixels=c,this.pixelType=t}extractBands(t){if(s(t)||0===t.length||null==this.pixels||0===this.pixels.length)return this;const e=this.pixels.length,i=t.some((t=>t>=this.pixels.length)),r=e===t.length&&!t.some(((t,s)=>t!==s));return i||r?this:new n({pixelType:this.pixelType,width:this.width,height:this.height,mask:this.mask,validPixelCount:this.validPixelCount,maskIsAlpha:this.maskIsAlpha,pixels:t.map((t=>this.pixels[t])),statistics:this.statistics&&t.map((t=>this.statistics[t]))})}clone(){const t=new n({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let s;this.mask&&(this.mask instanceof Uint8Array?t.mask=new Uint8Array(this.mask):t.mask=this.mask.slice(0));const i=n.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const e=this.pixels[0].slice;for(s=0;s<this.pixels.length;s++)t.pixels[s]=e?this.pixels[s].slice(0,this.pixels[s].length):new i(this.pixels[s])}if(this.statistics)for(t.statistics=[],s=0;s<this.statistics.length;s++)t.statistics[s]=e(this.statistics[s]);return t}_fillFrom8Bit(t){const{mask:s,maskIsAlpha:e,pixels:i}=this;if(!t||!i||!i.length)return void p.error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let r,l,a,o;r=l=a=i[0],i.length>=3?(l=i[1],a=i[2]):2===i.length&&(l=i[1]);const h=new Uint32Array(t),n=this.width*this.height;if(r.length===n)if(s&&s.length===n)if(e)for(o=0;o<n;o++)s[o]&&(h[o]=s[o]<<24|a[o]<<16|l[o]<<8|r[o]);else for(o=0;o<n;o++)s[o]&&(h[o]=255<<24|a[o]<<16|l[o]<<8|r[o]);else for(o=0;o<n;o++)h[o]=255<<24|a[o]<<16|l[o]<<8|r[o];else p.error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:s,mask:e,statistics:i}=this;if(!t||!s||!s.length)return void p.error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const r=this.pixelType;let l=1,a=0,o=1;if(i&&i.length>0)a=i.map((t=>t.minValue)).reduce(((t,s)=>Math.min(t,s))),o=i.map((t=>t.maxValue-t.minValue)).reduce(((t,s)=>Math.max(t,s))),l=255/o;else{let t=255;"s8"===r?(a=-128,t=127):"u16"===r?t=65535:"s16"===r?(a=-32768,t=32767):"u32"===r?t=4294967295:"s32"===r?(a=-2147483648,t=2147483647):"f32"===r?(a=-34e38,t=34e38):"f64"===r&&(a=-Number.MAX_VALUE,t=Number.MAX_VALUE),l=255/(t-a)}const h=new Uint32Array(t),n=this.width*this.height;let c,u,m,x,f;if(c=u=m=s[0],c.length!==n)return p.error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(s.length>=2)if(u=s[1],s.length>=3&&(m=s[2]),e&&e.length===n)for(x=0;x<n;x++)e[x]&&(h[x]=255<<24|(m[x]-a)*l<<16|(u[x]-a)*l<<8|(c[x]-a)*l);else for(x=0;x<n;x++)h[x]=255<<24|(m[x]-a)*l<<16|(u[x]-a)*l<<8|(c[x]-a)*l;else if(e&&e.length===n)for(x=0;x<n;x++)f=(c[x]-a)*l,e[x]&&(h[x]=255<<24|f<<16|f<<8|f);else for(x=0;x<n;x++)f=(c[x]-a)*l,h[x]=255<<24|f<<16|f<<8|f}_fillFrom32Bit(t){const{pixels:s,mask:e}=this;if(!t||!s||!s.length)return p.error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let i,r,l,a;i=r=l=s[0],s.length>=3?(r=s[1],l=s[2]):2===s.length&&(r=s[1]);const o=this.width*this.height;if(i.length!==o)return p.error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let h=0;if(e&&e.length===o)for(a=0;a<o;a++)t[h++]=i[a],t[h++]=r[a],t[h++]=l[a],t[h++]=1&e[a];else for(a=0;a<o;a++)t[h++]=i[a],t[h++]=r[a],t[h++]=l[a],t[h++]=1}_calculateBandStatistics(t,s){let e=1/0,i=-1/0;const r=t.length;let l,a=0;if(s)for(l=0;l<r;l++)s[l]&&(a=t[l],e=a<e?a:e,i=a>i?a:i);else for(l=0;l<r;l++)a=t[l],e=a<e?a:e,i=a>i?a:i;return{minValue:e,maxValue:i}}};t([a({json:{write:!0}})],c.prototype,"width",void 0),t([a({json:{write:!0}})],c.prototype,"height",void 0),t([a({json:{write:!0}})],c.prototype,"pixelType",void 0),t([o("pixelType")],c.prototype,"castPixelType",null),t([a({json:{write:!0}})],c.prototype,"validPixelCount",void 0),t([a({json:{write:!0}})],c.prototype,"mask",void 0),t([a({json:{write:!0}})],c.prototype,"maskIsAlpha",void 0),t([a({json:{write:!0}})],c.prototype,"pixels",void 0),t([a({json:{write:!0}})],c.prototype,"statistics",void 0),c=n=t([h("esri.layers.support.PixelBlock")],c);var u=c;export default u;
