/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import e from"../core/Error.js";import{L as r}from"../chunks/Loadable.js";import{L as n}from"../chunks/Logger.js";import{i as o,b as s}from"../core/lang.js";import{a as i}from"../chunks/Promise.js";import{whenOrAbort as a,eachAlwaysValues as c,isAborted as l,throwIfAborted as p}from"../core/promiseUtils.js";import{property as u}from"../core/accessorSupport/decorators/property.js";import"../chunks/ensureType.js";import{subclass as f}from"../core/accessorSupport/decorators/subclass.js";import{b as h,g as m,x as g,n as d,e as x,s as y,Z as v,t as w,f as b,p as j}from"../chunks/mathUtils.js";import A from"./Extent.js";import k from"./Geometry.js";import M from"./Point.js";import R from"./Polygon.js";import{c as F,a as P,b as O,d as U,f as L}from"../chunks/axisAngleDegrees.js";import z,{M as C,a as S}from"./support/MeshComponent.js";import{i as $,u as I,g as T,a as B,M as G}from"../chunks/georeference.js";import{t as E}from"../chunks/triangulationUtils.js";import{projectPointToVector as Z,computeLinearTransformation as q}from"./projection.js";import{makeRelative as D,removeFile as V}from"../core/urlUtils.js";import{f as N}from"../chunks/mat3.js";import{c as W}from"../chunks/quatf64.js";import{c as J}from"../chunks/mat4f64.js";import{c as _}from"../chunks/projectionEllipsoid.js";import{p as H,a as K,b as Q,c as X,d as Y,e as tt}from"../chunks/projection.js";import{i as et,b as rt}from"../chunks/mat4.js";import"../chunks/Message.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";import"../core/Accessor.js";import"../chunks/deprecate.js";import"../chunks/metadata.js";import"../chunks/handleUtils.js";import"../chunks/ArrayPool.js";import"../chunks/arrayUtils.js";import"../core/scheduling.js";import"./SpatialReference.js";import"../chunks/JSONSupport.js";import"../chunks/write.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../chunks/Ellipsoid.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/extentUtils.js";import"../chunks/zmUtils.js";import"../chunks/quat.js";import"../chunks/vec4.js";import"./support/MeshMaterial.js";import"../Color.js";import"../chunks/colorUtils.js";import"./support/MeshTexture.js";import"../chunks/persistableUrlUtils.js";import"../chunks/screenshotUtils.js";import"./support/MeshMaterialMetallicRoughness.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/BufferView.js";import"../chunks/vec2.js";import"../chunks/vec3.js";import"../chunks/earcut.js";import"../chunks/deduplicate.js";import"./Multipoint.js";import"../chunks/pe.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"./Polyline.js";import"../chunks/aaBoundingRect.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformation.js";import"./support/GeographicTransformationStep.js";const nt=n.getLogger("esri.geometry.support.meshUtils.centerAt");function ot(t,e,r){var n;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const s=null!=(n=null==r?void 0:r.origin)?n:t.origin;if(o(t.transform))null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&nt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e,r){const n=e.x-r.x,o=e.y-r.y,s=e.hasZ&&r.hasZ?e.z-r.z:0,i=t.origin;t.origin=[i[0]+n,i[1]+o,i[2]+s]}(t.transform,e,s);else{$(t.spatialReference,r)?function(t,e,r){const n=I(t.vertexAttributes,r,{geographic:!0}),{position:o,normal:s,tangent:i}=T(n,e,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,e,s):function(t,e,r){const n=it,o=st;if(!Z(e,o,t.spatialReference))return void nt.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`);if(!Z(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,nt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function(t,e,r){if(!t)return;for(let n=0;n<t.length;n+=3)for(let o=0;o<3;o++)t[n+o]+=e[o]-r[o]})(t.vertexAttributes.position,o,n),t.vertexAttributesChanged()}(t,e,s)}}const st=h(),it=h();function at(t){const e=V(t.url);return r=>{var n;const o=D(r,e,e),s=o?o.replace(/^ *\.\//,""):null;return null!=(n=t.files.get(s))?n:r}}async function ct(t,r){return t instanceof Blob?lt.fromBlob(t):"string"==typeof t?new lt(t):Array.isArray(t)?async function(t,r){const n=new Map;let o=null;const i=await c(t.map((async t=>({name:t.name,source:await ct(t instanceof Blob?t:t.source,r)})))),a=[];for(const t of i)t&&(l(r)?t.source.dispose():a.push(t));p(r);for(const{name:t,source:e}of a)(s(o)||/\.(gltf|glb)/i.test(t))&&(o=e.url),n.set(t,e.url),e.files&&e.files.forEach(((t,e)=>n.set(e,t)));if(s(o))throw new e("mesh-load-external:missing-files","Missing files to load external mesh source");return new lt(o,(()=>a.forEach((({source:t})=>t.dispose()))),n)}(t,r):async function(t,e){const{default:r}=await a(import("../request.js").then((function(t){return t.r})),e),n="string"==typeof t.multipart[0]?await Promise.all(t.multipart.map((async t=>(await r(t,{responseType:"array-buffer"})).data))):t.multipart;return lt.fromBlob(new Blob(n))}(t,r)}class lt{constructor(t,e=(()=>{}),r=new Map){this.url=t,this.dispose=e,this.files=r}static fromBlob(t){const e=URL.createObjectURL(t);return new lt(e,(()=>URL.revokeObjectURL(e)))}}const pt=n.getLogger("esri.geometry.support.meshUtils.offset");function ut(t,e,r){if(t.vertexAttributes&&t.vertexAttributes.position)if(o(t.transform))null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&pt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e){const r=t.origin;t.origin=m(h(),r,e)}(t.transform,e);else{$(t.spatialReference,r)?function(t,e){const r=t.spatialReference,n=t.vertexAttributes.position,s=t.vertexAttributes.normal,i=t.vertexAttributes.tangent,a=new Float64Array(n.length),c=o(s)?new Float32Array(s.length):null,l=o(i)?new Float32Array(i.length):null,p=t.extent.center,u=ht;q(r,[p.x,p.y,p.z],mt,_(r)),N(gt,mt),g(u,e,gt),H(n,r,a),o(s)&&K(s,n,a,r,c);o(i)&&Q(i,n,a,r,l);ft(a,u),X(a,n,r),o(s)&&Y(c,n,a,r,s);o(i)&&tt(l,n,a,r,i);t.vertexAttributesChanged()}(t,e):function(t,e){ft(t.vertexAttributes.position,e),t.vertexAttributesChanged()}(t,e)}}function ft(t,e){if(t)for(let r=0;r<t.length;r+=3)for(let n=0;n<3;n++)t[r+n]+=e[n]}const ht=h(),mt=J(),gt=W();const dt={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function xt(t,e,r){!function(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}(t),function(t,e){if(null==e)return;const r="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];bt[0]=r[0],bt[4]=r[1],bt[8]=r[2];for(let e=0;e<t.position.length;e+=3){for(let r=0;r<3;r++)wt[r]=t.position[e+r];g(wt,wt,bt);for(let r=0;r<3;r++)t.position[e+r]=wt[r]}if(r[0]!==r[1]||r[1]!==r[2]){bt[0]=1/r[0],bt[4]=1/r[1],bt[8]=1/r[2];for(let e=0;e<t.normal.length;e+=3){for(let r=0;r<3;r++)wt[r]=t.normal[e+r];g(wt,wt,bt),d(wt,wt);for(let r=0;r<3;r++)t.normal[e+r]=wt[r]}}}(t,r&&r.size);const{vertexAttributes:n,transform:o}=B(t,e,r);return{vertexAttributes:new C({...n,uv:t.uv}),transform:o,components:[new z({faces:t.faces,material:r&&r.material||null})],spatialReference:e.spatialReference}}const yt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},vt={south:0,east:1,north:2,west:3,up:4,down:5},wt=h(),bt=W(),jt=n.getLogger("esri.geometry.support.meshUtils.rotate");function At(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const n=t.spatialReference;if(o(t.transform)){var s;null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&jt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=null!=(s=null==r?void 0:r.origin)?s:t.transform.getOriginPoint(n);!function(t,e,r){const n=x(Mt,r.x,r.y,r.z),o=y(Mt,n,t.origin);t.applyLocalInverse(o,Rt),t.rotation=P(t.rotation,e,F()),t.applyLocalInverse(o,o),y(o,o,Rt),t.translation=m(h(),t.translation,o)}(t.transform,e,o)}else{var i;const n=null!=(i=null==r?void 0:r.origin)?i:t.origin;$(t.spatialReference,r)?function(t,e,r){const n=t.spatialReference,s=_(n),i=Ut;Z(r,i,s)||Z(t.origin,i,s);const a=t.vertexAttributes.position,c=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,p=new Float64Array(a.length),u=o(c)?new Float32Array(c.length):null,f=o(l)?new Float32Array(l.length):null;q(s,i,Pt,s),N(Ot,Pt);const h=Ft;g(O(Ft),O(e),Ot),h[3]=e[3],H(a,n,p),o(c)&&K(c,a,p,n,u);o(l)&&Q(l,a,p,n,f);kt(p,h,3,i),X(p,a,n),o(c)&&(kt(u,h,3),Y(u,a,p,n,c));o(l)&&(kt(f,h,4),tt(f,a,p,n,l));t.vertexAttributesChanged()}(t,e,n):function(t,e,r){const n=Ut;if(!Z(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,jt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}kt(t.vertexAttributes.position,e,3,n),kt(t.vertexAttributes.normal,e,3),kt(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}(t,e,n)}}function kt(t,e,r,n=v){if(!s(t)){et(Pt),rt(Pt,Pt,U(e),O(e));for(let e=0;e<t.length;e+=r){for(let r=0;r<3;r++)Mt[r]=t[e+r]-n[r];w(Mt,Mt,Pt);for(let r=0;r<3;r++)t[e+r]=Mt[r]+n[r]}}}const Mt=h(),Rt=h(),Ft=F(),Pt=J(),Ot=W(),Ut=h(),Lt=n.getLogger("esri.geometry.support.meshUtils.scale");function zt(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const n=t.spatialReference;if(o(t.transform)){var s;null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&Lt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=null!=(s=null==r?void 0:r.origin)?s:t.transform.getOriginPoint(n);!function(t,e,r){const n=x(St,r.x,r.y,r.z),o=y(St,n,t.origin);t.applyLocalInverse(o,$t);const s=b(h(),t.scale,e);t.scale=s,t.applyLocalInverse(o,o),y(o,o,$t),t.translation=m(h(),t.translation,o)}(t.transform,e,o)}else{const n=$(t.spatialReference,r),s=r&&r.origin||t.origin;n?function(t,e,r){const n=t.spatialReference,s=_(n),i=It;Z(r,i,s)||Z(t.origin,i,s);const a=t.vertexAttributes.position,c=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,p=new Float64Array(a.length),u=o(c)?new Float32Array(c.length):null,f=o(l)?new Float32Array(l.length):null;H(a,n,p),o(c)&&K(c,a,p,n,u);o(l)&&Q(l,a,p,n,f);Ct(p,e,i),X(p,a,n),o(c)&&Y(u,a,p,n,c);o(l)&&tt(f,a,p,n,l);t.vertexAttributesChanged()}(t,e,s):function(t,e,r){const n=It;if(!Z(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,Lt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Ct(t.vertexAttributes.position,e,n),t.vertexAttributesChanged()}(t,e,s)}}function Ct(t,e,r=v){if(t)for(let n=0;n<t.length;n+=3){for(let e=0;e<3;e++)St[e]=t[n+e]-r[e];b(St,St,e);for(let e=0;e<3;e++)t[n+e]=St[e]+r[e]}}const St=h(),$t=h(),It=h();var Tt;const Bt=n.getLogger("esri.geometry.Mesh");let Gt=Tt=class extends(r.LoadableMixin(i(k))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new S,this.type="mesh"}initialize(){(s(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded")}get hasExtent(){return!this.loaded&&o(this.external)&&o(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,e=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new A({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e}),center:new M({x:0,y:0,z:0,spatialReference:e})};const r=o(this.transform)?this.transform.project(t,e):t;let n=1/0,s=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0,p=0,u=0,f=0;const h=r.length,m=1/(h/3);let g=0;for(;g<h;){const t=r[g++],e=r[g++],o=r[g++];n=Math.min(n,t),s=Math.min(s,e),i=Math.min(i,o),a=Math.max(a,t),c=Math.max(c,e),l=Math.max(l,o),p+=m*t,u+=m*e,f+=m*o}return{extent:new A({xmin:n,ymin:s,zmin:i,xmax:a,ymax:c,zmax:l,spatialReference:e}),center:new M({x:p,y:u,z:f,spatialReference:e})}}get anchor(){if(o(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new M({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return o(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&o(this.external)&&o(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(z.from(t)),this.notifyChange("components")):Bt.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}Bt.error("removeComponent()","Provided component is not part of the list of components")}else Bt.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,r,n){return L(Et.x,t,Zt),L(Et.y,e,qt),L(Et.z,r,Dt),P(Zt,qt,Zt),P(Zt,Dt,Zt),At(this,Zt,n),this}offset(t,e,r,n){return this.loaded?(Vt[0]=t,Vt[1]=e,Vt[2]=r,ut(this,Vt,n),this):(Bt.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(zt(this,t,e),this):(Bt.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(ot(this,t,e),this):(Bt.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return o(this.external)&&this.addResolvingPromise(async function(t,e,r){const{loadGLTFMesh:n}=await a(import("../chunks/loadGLTFMesh.js"),r),s=await ct(e,r),i=n(new M({x:0,y:0,z:0,spatialReference:t.spatialReference}),s.url,{resolveFile:at(s),useTransform:!0,signal:o(r)?r.signal:null});i.then((()=>s.dispose()),(()=>s.dispose()));const{vertexAttributes:c,components:l}=await i;t.vertexAttributes=c,t.components=l}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,e=this.components?new Map:null,r={components:this.components?this.components.map((r=>r.cloneWithDeduplication(t,e))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:o(this.transform)?this.transform.clone():null,external:o(this.external)?{source:this.external.source,extent:o(this.external.extent)?this.external.extent.clone():null}:null};return new Tt(r)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await import("../chunks/gltfexport.js");return e(this,t)}static createBox(t,e){if(!(t instanceof M))return Bt.error(".createBox()","expected location to be a Point instance"),null;const r=new Tt(xt(function(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:r}=yt,n=4*t.length,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(2*t.length*3);let c=0,l=0,p=0,u=0;for(let n=0;n<t.length;n++){const f=t[n],h=c/3;for(const t of e)a[u++]=h+t;const m=f.corners;for(let t=0;t<4;t++){const e=m[t];let n=0;i[p++]=.25*r[t][0]+f.uvOrigin[0],i[p++]=f.uvOrigin[1]-.25*r[t][1];for(let t=0;t<3;t++)0!==f.axis[t]?(o[c++]=.5*f.axis[t],s[l++]=f.axis[t]):(o[c++]=.5*e[n++],s[l++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?function(t,e){const r=t.components[0],n=r.faces,s=vt[e],i=6*s,a=new Uint32Array(6),c=new Uint32Array(n.length-6);let l=0,p=0;for(let t=0;t<n.length;t++)t>=i&&t<i+6?a[l++]=n[t]:c[p++]=n[t];if(o(t.vertexAttributes.uv)){const e=new Float32Array(t.vertexAttributes.uv),r=4*s*2,n=[0,1,1,1,1,0,0,0];for(let t=0;t<n.length;t++)e[r+t]=n[t];t.vertexAttributes.uv=e}return t.components=[new z({faces:a,material:r.material}),new z({faces:c})],t}(r,e.imageFace):r}static createSphere(t,e){return t instanceof M?new Tt(xt(function(t=0){const e=Math.round(8*2**t),r=2*e,n=(e-1)*(r+1)+2*r,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array((e-1)*r*2*3);let c=0,l=0,p=0,u=0;for(let t=0;t<=e;t++){const n=t/e*Math.PI+.5*Math.PI,f=Math.cos(n),h=Math.sin(n);wt[2]=h;const m=0===t||t===e,g=m?r-1:r;for(let n=0;n<=g;n++){const h=n/g*2*Math.PI;wt[0]=-Math.sin(h)*f,wt[1]=Math.cos(h)*f;for(let t=0;t<3;t++)o[c]=.5*wt[t],s[c]=wt[t],++c;i[l++]=(n+(m?.5:0))/r,i[l++]=t/e,0!==t&&n!==r&&(t!==e&&(a[p++]=u,a[p++]=u+1,a[p++]=u-r),1!==t&&(a[p++]=u,a[p++]=u-r,a[p++]=u-r-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(e&&e.densificationFactor||0),t,e)):(Bt.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof M?new Tt(xt(function(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,n=new Float64Array(3*r),o=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(4*e*3);let a=0,c=0,l=0,p=0,u=0;for(let t=0;t<=5;t++){const r=0===t||5===t,f=t<=1||t>=4,h=2===t||4===t,m=r?e-1:e;for(let g=0;g<=m;g++){const d=g/m*2*Math.PI,x=r?0:.5;wt[0]=x*Math.sin(d),wt[1]=x*-Math.cos(d),wt[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)n[a++]=wt[e],o[c++]=f?2===e?t<=1?1:-1:0:2===e?0:wt[e]/x;s[l++]=(g+(r?.5:0))/e,s[l++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,h||0===t||g===e||(5!==t&&(i[p++]=u,i[p++]=u+1,i[p++]=u-e),1!==t&&(i[p++]=u,i[p++]=u-e,i[p++]=u-e-1)),u++}}return{position:n,normal:o,uv:s,faces:i}}(e&&e.densificationFactor||0),t,e)):(Bt.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){return t instanceof M?new Tt(xt(function(t){const e=dt.facingAxisOrderSwap[t],r=dt.position,n=dt.normal,o=new Float64Array(r.length),s=new Float32Array(n.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const c=e[a],l=Math.abs(c)-1,p=c>=0?1:-1;o[i]=r[t+l]*p,s[i]=n[t+l]*p,i++}}return{position:o,normal:s,uv:new Float32Array(dt.uv),faces:new Uint32Array(dt.faces)}}(e&&e.facing||"up"),t,e)):(Bt.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(t,e){if(!(t instanceof R))return Bt.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const r=E(t);return new Tt({vertexAttributes:new S({position:r.position}),components:[new z({faces:r.faces,shading:"flat",material:e&&e.material||null})],spatialReference:t.spatialReference})}static async createFromGLTF(t,r,n){if(!(t instanceof M))throw Bt.error(".createfromGLTF()","expected location to be a Point instance"),new e("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await a(import("../chunks/loadGLTFMesh.js"),n);return new Tt(await o(t,r,n))}static createWithExternalSource(t,e,r){var n,o,s;const i=null!=(n=null==r?void 0:r.extent)?n:null,a=null!=(o=null==r?void 0:r.transform.clone())?o:new G;a.origin=[t.x,t.y,null!=(s=t.z)?s:0];const c=t.spatialReference;return new Tt({external:{source:e,extent:i},transform:a,spatialReference:c})}static createIncomplete(t,r){var n,o;const s=null!=(n=null==r?void 0:r.transform.clone())?n:new G;s.origin=[t.x,t.y,null!=(o=t.z)?o:0];const i=t.spatialReference,a=new Tt({transform:s,spatialReference:i});return a.addResolvingPromise(Promise.reject(new e("mesh-incomplete","Mesh resources are not complete"))),a}};t([u({type:[z],json:{write:!0}})],Gt.prototype,"components",void 0),t([u({type:G,json:{write:!0}})],Gt.prototype,"transform",void 0),t([u({constructOnly:!0})],Gt.prototype,"external",void 0),t([u({readOnly:!0})],Gt.prototype,"hasExtent",null),t([u({readOnly:!0})],Gt.prototype,"boundingInfo",null),t([u({readOnly:!0})],Gt.prototype,"anchor",null),t([u({readOnly:!0})],Gt.prototype,"origin",null),t([u({readOnly:!0,json:{read:!1}})],Gt.prototype,"extent",null),t([u({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Gt.prototype,"hasZ",void 0),t([u({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Gt.prototype,"hasM",void 0),t([u({type:S,nonNullable:!0,json:{write:!0}})],Gt.prototype,"vertexAttributes",void 0),Gt=Tt=t([f("esri.geometry.Mesh")],Gt);const Et={x:j(1,0,0),y:j(0,1,0),z:j(0,0,1)},Zt=F(),qt=F(),Dt=F(),Vt=h();var Nt=Gt;export default Nt;
